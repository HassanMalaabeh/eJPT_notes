# Port Scanning & Enumeration – Windows (eJPT)

Note: The transcript for “03 - Port Scanning & Enumeration - Windows.mp4” is not provided. The notes below are a conservative, exam-focused workflow inferred from the filename and Windows exploitation context typical of eJPT labs.

## What the video covers (Introduction / big picture)
- How to discover and profile Windows hosts via network scanning.
- Reading Windows-specific ports and services (SMB, RPC, RDP, WinRM, AD/LDAP/Kerberos, MSSQL, DNS).
- Moving from fast discovery to deeper, service-focused enumeration.
- Practical commands to collect users, shares, OS/domain info, and potential entry points.

## Flow (ordered)
1. Define target/scope and create an output folder.
2. Fast TCP sweep to find open ports (ICMP often blocked on Windows, so treat host as alive).
3. Focused service/version scan and OS detection on discovered ports.
4. Targeted UDP check (SNMP/NBNS/…).
5. Interpret Windows-specific ports, identify if it’s a Domain Controller vs standalone server.
6. SMB/RPC enumeration (anonymous/null first).
7. If AD-related ports open: LDAP/Kerberos enumeration, discover domain and base DN.
8. Enumerate RDP/WinRM/MSSQL/HTTP services if present.
9. Log and prioritize follow-up (shares, users, weak configs, reachable management services).

## Tools highlighted
- Port scanning: nmap (primary), optional: rustscan.
- SMB/RPC/AD: smbclient, smbmap, enum4linux-ng, rpcclient, Impacket (lookupsid.py), CrackMapExec (cme/netexec).
- LDAP/Kerberos: ldapsearch, nmap NSE (ldap-*), kerbrute (careful with lockouts), windapsearch (optional).
- RDP/WinRM: nmap NSE (rdp-*), xfreerdp, evil-winrm, cme winrm.
- MSSQL: nmap ms-sql-* scripts, impacket-mssqlclient.
- HTTP: whatweb, nmap http-* scripts, gobuster/dirsearch.
- UDP/Other: snmpwalk/onesixtyone, nbtscan.

## Typical command walkthrough (detailed, copy-paste friendly)

Set variables and workspace
```bash
export TARGET=10.10.10.10
mkdir -p scans
```

Initial reachability and quick fingerprint (don’t rely on ICMP)
```bash
# ICMP may be blocked; ok if it doesn’t reply
ping -c 1 $TARGET || echo "No ICMP response (common on Windows). Proceeding with -Pn."
```

All TCP ports (fast) and extract open list
```bash
nmap -n -Pn -T4 --min-rate 2000 -p- -oA scans/$TARGET-alltcp $TARGET

# Build comma-separated list of open TCP ports
ports=$(grep -oP '\d{1,5}/open' scans/$TARGET-alltcp.gnmap | cut -d/ -f1 | sort -n | tr '\n' ',' | sed 's/,$//')
echo "Open TCP ports: $ports"
```

Service/version scripts and OS guess on discovered ports
```bash
nmap -n -Pn -T4 -sC -sV -O -p $ports -oA scans/$TARGET-tcpdetail $TARGET
```

Targeted UDP (top ports or specific ones)
```bash
nmap -n -sU --top-ports 20 -oA scans/$TARGET-udp-top $TARGET
# If 161 appears:
nmap -n -sU -p 161 --script snmp-info $TARGET
```

Windows-specific quick NSE probes
```bash
# SMB OS/security info
nmap -n -p 445 --script "smb-os-discovery,smb2-security-mode,smb2-time" -oN scans/$TARGET-smb-os.txt $TARGET

# RDP info
nmap -n -p 3389 --script "rdp-ntlm-info,rdp-enum-encryption" -oN scans/$TARGET-rdp.txt $TARGET

# LDAP rootDSE
nmap -n -p 389 --script "ldap-rootdse,ldap-naming-contexts" -oN scans/$TARGET-ldap-rootdse.txt $TARGET 2>/dev/null || true
```

SMB enumeration (null/guest first)
```bash
# List shares (null session)
smbclient -L //$TARGET/ -N | tee scans/$TARGET-smb-shares.txt

# If shares exist, try access with guest/null
# Example: replace SHARE with an actual share name found above
# smbclient //${TARGET}/SHARE -N

# Programmatic share listing
smbmap -H $TARGET | tee scans/$TARGET-smbmap.txt

# Broad SMB/RPC enum
enum4linux-ng -A $TARGET | tee scans/$TARGET-e4l.txt
```

RPC and SID/RID enumeration
```bash
# RPC null session; run multiple commands in one go
rpcclient -U "" $TARGET << 'EOF' | tee scans/$TARGET-rpcclient.txt
lsaquery
enumdomusers
enumdomgroups
querydominfo
EOF

# Impacket SID brute (anonymous, if allowed)
lookupsid.py anonymous@$TARGET -no-pass | tee scans/$TARGET-lookupsid.txt
```

CrackMapExec quick profiling
```bash
# Basic info, SMB signing, shares via null
cme smb $TARGET | tee scans/$TARGET-cme-info.txt
cme smb $TARGET -u '' -p '' --shares | tee scans/$TARGET-cme-shares.txt
```

Detecting a Domain Controller and extracting domain info
- Indicators: open 88/135/389/445/464/53/3268/3269; SMB says “Domain: CORP”; hostnames like DC01; dnsservice.
```bash
# LDAP naming contexts (base DN)
nmap -n -p389 --script ldap-rootdse $TARGET -oN scans/$TARGET-ldap-rootdse.txt

# If anonymous bind is enabled (lab-dependent), enumerate:
# Replace DC=corp,DC=local with actual namingContexts (see ldap-rootdse output)
ldapsearch -x -H ldap://$TARGET -s base namingContexts | tee scans/$TARGET-ldap-nc.txt
ldapsearch -x -H ldap://$TARGET -b "DC=corp,DC=local" "(objectClass=user)" sAMAccountName | tee scans/$TARGET-ldap-users.txt
```

Kerberos user enumeration (careful with lockouts in real environments)
```bash
# Example only; ensure rules allow it
# kerbrute userenum --dc $TARGET -d corp.local wordlists/users.txt -o scans/$TARGET-kerbrute.txt
```

RDP and WinRM checks
```bash
# RDP already checked via NSE; to try a login (if creds later):
# xfreerdp /v:$TARGET /u:USER /p:PASS /cert:ignore +clipboard /dynamic-resolution

# WinRM detection and test with creds (if obtained later)
nmap -n -p 5985,5986 $TARGET -oN scans/$TARGET-winrm.txt
# cme winrm $TARGET -u USER -p PASS
# evil-winrm -i $TARGET -u USER -p PASS
```

MSSQL enumeration (if 1433 open)
```bash
nmap -n -p1433 --script "ms-sql-info,ms-sql-ntlm-info,ms-sql-empty-password" -oN scans/$TARGET-mssql.txt $TARGET
# With creds:
# impacket-mssqlclient -windows-auth DOMAIN/USER@$TARGET
```

DNS quick checks (if 53 open)
```bash
# Forward lookup (if you know a hostname)
# dig @${TARGET} host.corp.local A

# Zone transfer (rarely allowed; try only if you’ve identified a domain)
# dig @${TARGET} corp.local AXFR
```

HTTP on IIS (if 80/443/8080 open)
```bash
whatweb http://$TARGET | tee scans/$TARGET-whatweb.txt
nmap -n -p 80,443,8080 --script "http-title,http-methods,http-server-header,http-headers" -oN scans/$TARGET-http.txt $TARGET
# Directory brute (adjust wordlist/extension)
# gobuster dir -u http://$TARGET -w /usr/share/wordlists/dirb/common.txt -x aspx,asp,txt -o scans/$TARGET-gobuster.txt
```

SNMP (if UDP 161 open)
```bash
snmpwalk -v2c -c public $TARGET 1.3.6.1.2.1.1 | tee scans/$TARGET-snmp.txt
```

NBNS/NetBIOS (helpful for names)
```bash
# Quick NetBIOS name lookup (UDP 137)
# nbtscan -r $TARGET/32
```

## Practical tips
- Treat Windows targets as “alive” even without ping; use -Pn in nmap.
- When you see many high TCP ports “open” along with 135, that’s typical RPC endpoint mapping; focus on 135/139/445/3389/5985/88/389/1433/53 first.
- 88/389/445/53 together usually means a Domain Controller; expect LDAP and Kerberos enumeration opportunities.
- Start with null/guest SMB checks before noisy or credentialed attempts.
- Save outputs (-oA/-oN) and keep a running list of ports, shares, users, and domain info.
- Be careful with kerbrute/password spraying in real environments (lockouts). In labs, it’s often permitted.
- For SMB, both 139 and 445 may be present; 445 alone is common on modern Windows.
- RDP may require NLA; you’ll need valid credentials. WinRM often grants PowerShell once you have creds.
- If LDAP anonymous bind fails, rely on SMB/RPC to learn the domain (rpcclient lsaquery, lookupsid.py) and pivot later with creds.

## Minimal cheat sheet (one-screen flow)
```bash
export TARGET=10.10.10.10; mkdir -p scans

# TCP sweep -> list -> detail
nmap -n -Pn -T4 --min-rate 2000 -p- -oA scans/$TARGET-alltcp $TARGET
ports=$(grep -oP '\d{1,5}/open' scans/$TARGET-alltcp.gnmap|cut -d/ -f1|sort -n|tr '\n' ','|sed 's/,$//')
nmap -n -Pn -T4 -sC -sV -O -p $ports -oA scans/$TARGET-tcpdetail $TARGET

# UDP top ports
nmap -n -sU --top-ports 20 -oA scans/$TARGET-udp-top $TARGET

# SMB quick wins
nmap -n -p445 --script "smb-os-discovery,smb2-security-mode" -oN scans/$TARGET-smb-os.txt $TARGET
smbclient -L //$TARGET/ -N | tee scans/$TARGET-smb-shares.txt
smbmap -H $TARGET | tee scans/$TARGET-smbmap.txt
enum4linux-ng -A $TARGET | tee scans/$TARGET-e4l.txt
rpcclient -U "" $TARGET << 'EOF' | tee scans/$TARGET-rpcclient.txt
lsaquery
enumdomusers
enumdomgroups
EOF
lookupsid.py anonymous@$TARGET -no-pass | tee scans/$TARGET-lookupsid.txt

# AD hints (if 389/88/53 open)
nmap -n -p389 --script ldap-rootdse -oN scans/$TARGET-ldap-rootdse.txt $TARGET
# ldapsearch -x -H ldap://$TARGET -s base namingContexts
# ldapsearch -x -H ldap://$TARGET -b "DC=corp,DC=local" "(objectClass=user)" sAMAccountName

# RDP/WinRM/MSSQL
nmap -n -p3389 --script "rdp-ntlm-info,rdp-enum-encryption" -oN scans/$TARGET-rdp.txt $TARGET
nmap -n -p5985,5986 -oN scans/$TARGET-winrm.txt $TARGET
nmap -n -p1433 --script "ms-sql-info,ms-sql-empty-password" -oN scans/$TARGET-mssql.txt $TARGET

# HTTP quick enum (if present)
whatweb http://$TARGET | tee scans/$TARGET-whatweb.txt
nmap -n -p80,443,8080 --script "http-title,http-methods" -oN scans/$TARGET-http.txt $TARGET
```

## Summary
- Start with a fast, host-alive-agnostic TCP sweep (-Pn), then deepen with -sC -sV -O on found ports.
- Interpret Windows ports to identify role: SMB/RPC for shares/users; RDP/WinRM for management; LDAP/Kerberos/DNS for Domain Controllers; MSSQL/HTTP for app surfaces.
- Prioritize null and unauthenticated checks first (SMB/RPC/LDAP rootDSE), then expand based on findings.
- Log everything for later credential reuse and exploitation steps; the enumeration here sets up the rest of the Windows exploitation workflow.