# 03 - Obfuscating PowerShell Code (eJPT Study Notes)

Note: No transcript was provided. The following summary is inferred conservatively from the filename and module context (01-AVEvasion&Obfuscation). Commands demonstrate harmless, lab-only examples intended for authorized testing and defensive understanding.

## What the video covers (Introduction / big picture)
- What PowerShell obfuscation is and why it matters in authorized security testing.
- Common, low-friction obfuscation techniques:
  - Token/lexical obfuscation (renaming, casing, concatenation).
  - String-level obfuscation (char codes, environment variables).
  - Encoding-based obfuscation (-EncodedCommand Base64, sometimes with compression).
- How defenders detect/triage obfuscation (e.g., Script Block Logging, AMSI, Event ID 4104) and how to safely deobfuscate.
- Emphasis on lab-only, ethical use to evaluate detection and hardening, not to bypass security controls illicitly.

## Flow (ordered)
1. Start with a simple, readable PowerShell command/script.
2. Apply basic lexical/string obfuscation (concatenation, mixed case, variables).
3. Apply Base64 obfuscation with -EncodedCommand (PowerShell expects UTF-16LE).
4. (Optional) Layered obfuscation: compress (GZip) then Base64.
5. Execute benign obfuscated content in a lab to see behavior and logs.
6. Deobfuscate and review logs to understand visibility (e.g., Event ID 4104).
7. Discuss pros/cons and detection considerations.

## Tools highlighted
- PowerShell built-ins:
  - Invoke-Expression (IEX) for demonstration only (avoid in production).
  - [Convert]::ToBase64String / FromBase64String
  - [System.Text.Encoding]::Unicode
  - [IO.Compression.GzipStream] for compression
  - Get-WinEvent / wevtutil for log review
- Analysis aids (defensive/lab):
  - CyberChef (Base64 encode/decode, GZip)
  - PowerShell AST ([System.Management.Automation.Language.Parser]) for static inspection

## Typical command walkthrough (detailed, copy-paste friendly)

All examples are benign and for authorized lab use only.

1) Baseline: readable code
```powershell
Write-Host "Hello from the lab"
Get-Date
```

2) Simple lexical obfuscation (concatenation and variables)
```powershell
# Break up cmdlet names and strings
("Wri" + "te-Host") ("He" + "llo " + "from " + "the " + "lab")
$g = 'Get' + '-' + 'Process'
& $g | Select-Object -First 3
```

3) Character code obfuscation (build a string from char codes)
```powershell
# "Hello lab" via char codes
$codes = 72,101,108,108,111,32,108,97,98
$msg = -join ($codes | ForEach-Object { [char]$_ })
Write-Host $msg
```

4) Base64 encoding and execution via -EncodedCommand
- PowerShell expects UTF-16LE (aka “Unicode” in .NET) before Base64 encoding.
```powershell
# Build the command to encode
$command = 'Write-Host "Hello from the lab"; Get-Date'

# Encode to Base64 (UTF-16LE)
$bytes   = [System.Text.Encoding]::Unicode.GetBytes($command)
$encoded = [Convert]::ToBase64String($bytes)
$encoded  # Copy this value
```

Run it (new console):
```powershell
powershell.exe -NoProfile -EncodedCommand <PASTE_BASE64_HERE>
```

Decode Base64 back to plain text (defensive/deobfuscation side):
```powershell
$encoded = '<PASTE_BASE64_HERE>'
[System.Text.Encoding]::Unicode.GetString([Convert]::FromBase64String($encoded))
```

5) Optional: GZip + Base64 (layered obfuscation; decoding only prints the result)
Compress to Base64:
```powershell
$payload = 'Write-Host "Hello lab (decompressed)"; Get-Date'
$bytes   = [System.Text.Encoding]::Unicode.GetBytes($payload)

$ms = New-Object IO.MemoryStream
$gz = New-Object IO.Compression.GzipStream($ms, [IO.Compression.CompressionMode]::Compress)
$gz.Write($bytes, 0, $bytes.Length)
$gz.Close()

$compressed = $ms.ToArray()
$ms.Close()

$encodedGzip = [Convert]::ToBase64String($compressed)
$encodedGzip  # Copy this for decoding
```

Decode and view (no execution; just reveal plaintext):
```powershell
$in   = [Convert]::FromBase64String('<PASTE_BASE64_GZIP_HERE>')
$ms2  = New-Object IO.MemoryStream(,$in)
$gz2  = New-Object IO.Compression.GzipStream($ms2, [IO.Compression.CompressionMode]::Decompress)
$sr   = New-Object IO.StreamReader($gz2, [Text.Encoding]::Unicode)
$txt  = $sr.ReadToEnd()
$sr.Close(); $gz2.Close(); $ms2.Close()
$txt  # Revealed script text
```

6) Reviewing PowerShell operational logs (Script Block Logging, Event ID 4104)
```powershell
# Requires PowerShell Logging to be enabled in policy
Get-WinEvent -LogName 'Microsoft-Windows-PowerShell/Operational' |
  Where-Object { $_.Id -eq 4104 } |
  Select-Object -First 5 -Property TimeCreated, Id, Message
```

Alternatively (CMD/PowerShell):
```powershell
wevtutil qe Microsoft-Windows-PowerShell/Operational /q:"*[System[(EventID=4104)]]" /f:text /c:5
```

7) Using the PowerShell parser (AST) to extract strings (defensive inspection)
```powershell
$code   = '("Wri"+"te-Host") "Hi"; $x = 72,101,108,108,111'
$tokens = $null; $errors = $null
$ast    = [System.Management.Automation.Language.Parser]::ParseInput($code, [ref]$tokens, [ref]$errors)

# Show all string constants discovered by the parser
$ast.FindAll({ param($n) $n -is [System.Management.Automation.Language.StringConstantExpressionAst] }, $true) |
  Select-Object -ExpandProperty Value
```

## Practical tips
- Only in authorized environments. Document scope, approvals, and test plans.
- PowerShell Base64 encoding for -EncodedCommand is UTF-16LE. If you use UTF-8, it will fail.
- Keep examples benign. Avoid network retrieval or sensitive actions in demos.
- Expect detection: Script Block Logging (Event ID 4104), AMSI scanning, EDR hooks.
- For defenders: practice decoding, decompressing, and AST parsing to triage obfuscated scripts.
- Obfuscation is not encryption. Assume determined defenders can recover the plaintext.
- Avoid Invoke-Expression (IEX) in production code; it increases risk and is a detection magnet.
- Keep a clean baseline and diff your obfuscation steps to understand exactly what changed.

## Minimal cheat sheet (one-screen flow)
- Concatenation:
```powershell
("Wri"+"te-Host") "Hello lab"
$cmd='Get'+'-'+'Process'; & $cmd | Select-Object -First 3
```
- From char codes:
```powershell
-join (72,101,108,108,111 | % {[char]$_})
```
- Encode for -EncodedCommand (UTF-16LE):
```powershell
$cmd='Write-Host "Hello from the lab"; Get-Date'
[Convert]::ToBase64String([Text.Encoding]::Unicode.GetBytes($cmd))
```
- Run encoded:
```powershell
powershell.exe -NoProfile -EncodedCommand <BASE64>
```
- Decode Base64 (defensive):
```powershell
[Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('<BASE64>'))
```
- GZip + Base64 encode:
```powershell
$pl='Write-Host "Hello lab (decompressed)"; Get-Date'
$ms=New-Object IO.MemoryStream
$gz=New-Object IO.Compression.GzipStream($ms,[IO.Compression.CompressionMode]::Compress)
$bytes=[Text.Encoding]::Unicode.GetBytes($pl); $gz.Write($bytes,0,$bytes.Length); $gz.Close()
[Convert]::ToBase64String($ms.ToArray())
```
- GZip + Base64 decode (print only):
```powershell
$in=[Convert]::FromBase64String('<BASE64_GZIP>')
$ms2=New-Object IO.MemoryStream(,$in)
$gz2=New-Object IO.Compression.GzipStream($ms2,[IO.Compression.CompressionMode]::Decompress)
(new-object IO.StreamReader($gz2,[Text.Encoding]::Unicode)).ReadToEnd()
```
- Recent 4104 events:
```powershell
Get-WinEvent -LogName 'Microsoft-Windows-PowerShell/Operational' |
? Id -eq 4104 | Select -First 5 TimeCreated,Id,Message
```

## Summary
This session (inferred) introduces practical PowerShell obfuscation techniques for authorized testing and defensive analysis. It demonstrates benign examples of token and string manipulation, Base64 with -EncodedCommand, and optional compression layering, then pivots to deobfuscation and logging to understand visibility (e.g., Event ID 4104). Key takeaways: keep it ethical and lab-only, know UTF-16LE requirements for -EncodedCommand, assume obfuscation is discoverable, and build proficiency in decoding and log review to strengthen detection and response.