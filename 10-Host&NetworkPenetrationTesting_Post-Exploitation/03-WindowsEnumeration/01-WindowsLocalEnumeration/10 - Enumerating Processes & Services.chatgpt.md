# 10 - Enumerating Processes & Services (Windows Local Enumeration)

Note: No transcript was provided. The following is a conservative, exam-focused summary inferred from the filename and folder context (01-WindowsLocalEnumeration), using standard eJPT-style Windows local enumeration practices.

## What the video covers (Introduction / big picture)
- How to enumerate Windows processes and services locally after initial access.
- Mapping processes to services and to network ports.
- Pulling actionable configuration details: binary paths, accounts, start modes, PIDs.
- Identifying common privilege-escalation leads:
  - Unquoted service paths
  - Weak service permissions (change config/start/stop)
  - Writable service binaries or folders
  - High-privilege service accounts (LocalSystem) running non-Microsoft binaries
  - Sensitive command-line arguments in processes
- Using built-in tools first, then optional Sysinternals/PowerShell for deeper insight.

## Flow (ordered)
1. Baseline who/what you are:
   - Identify privileges and integrity level.
2. Enumerate running processes with details:
   - Names, PIDs, owners, paths, command lines.
3. Map processes to network ports and to hosted services.
4. Enumerate services with configuration:
   - StartType, StartName (account), binary path (quotes?), PID.
5. Hunt misconfigurations:
   - Non-quoted paths with spaces, non-MS binaries as SYSTEM, auto-start third-party services.
6. Check permissions:
   - Service DACLs (change-config/start/stop) and file/folder ACLs on service binaries/paths.
7. Shortlist viable escalation paths (note required privileges and restart triggers).
8. If safe/allowed, validate by starting/stopping a test service; otherwise, document.

## Tools highlighted
- Built-in (CMD):
  - whoami /priv, tasklist (/v, /svc), taskkill, sc (query, queryex, qc, sdshow, start/stop), net start
  - wmic service / wmic process (where available), findstr, netstat -ano, icacls, dir /q
- PowerShell:
  - Get-Process, Get-Service, Get-WmiObject Win32_Service or Get-CimInstance Win32_Service/Win32_Process
  - Get-NetTCPConnection, Select-Object, Where-Object
- Sysinternals (optional but very useful):
  - AccessChk.exe (service and file ACLs), Process Explorer / Process Hacker

## Typical command walkthrough (detailed, copy-paste friendly)

Baseline
```
whoami /priv
whoami /groups
```

Processes (CMD)
```
:: All processes, verbose (shows user, window titles)
tasklist /v /fo table

:: Processes running as SYSTEM
tasklist /v /fi "username eq SYSTEM"

:: Show process-to-service mapping (svchost groups, service-hosted processes)
tasklist /svc

:: Process details with command lines and paths
wmic process get Name,ProcessId,ParentProcessId,ExecutablePath,CommandLine /format:list

:: Hunt for potentially sensitive command-line args
wmic process get CommandLine,ProcessId,Name | findstr /ri "passw|pwd|user|key|token|secret"
```

Processes (PowerShell)
```
# Process list with owners (PS5+)
Get-Process -IncludeUserName | Select-Object Name,Id,UserName,Path,StartTime | Sort-Object Name

# Command lines and paths (more comprehensive)
Get-CimInstance Win32_Process | Select-Object Name,ProcessId,ExecutablePath,CommandLine | Format-Table -Auto

# Grep for secrets in command lines
Get-CimInstance Win32_Process | Where-Object {$_.CommandLine -match 'pass|pwd|key|token|secret'} `
| Select-Object Name,ProcessId,CommandLine
```

Network ports to processes
```
:: Listeners with PIDs
netstat -ano | findstr LISTENING

:: Inspect the owning process by PID (example PID 1234)
tasklist /fi "PID eq 1234" /v
```

Services (CMD)
```
:: All services and state (extended, includes PID)
sc queryex type= service state= all

:: Running services only
sc query type= service state= active

:: Configuration (binary path, start type, run account)
sc qc "ServiceName"

:: Security descriptor (DACL in SDDL)
sc sdshow "ServiceName"

:: Currently running services (names only)
net start
```

Services (WMIC/PowerShell)
```
:: WMIC: full view with path and account
wmic service get Name,DisplayName,State,StartMode,StartName,ProcessId,PathName

:: Auto-start third-party services (filter Windows in path)
wmic service where "StartMode='Auto' AND NOT PathName LIKE '%\\Windows\\%'" get Name,DisplayName,StartName,PathName

:: Unquoted service paths (spaces but no leading quote)
wmic service where "StartMode='Auto' AND PathName LIKE '% %' AND NOT PathName LIKE '\"%'" get Name,DisplayName,PathName
```

PowerShell equivalents
```
# Services comprehensive view
Get-CimInstance Win32_Service | Select-Object Name,DisplayName,State,StartMode,StartName,ProcessId,PathName

# Auto-start, likely third-party
Get-CimInstance Win32_Service | Where-Object {$_.StartMode -eq 'Auto' -and $_.PathName -notmatch '\\Windows\\'} `
| Select-Object Name,DisplayName,StartName,PathName

# Unquoted service paths (space present and no leading quote)
Get-WmiObject Win32_Service | Where-Object {
  $_.StartMode -eq 'Auto' -and $_.PathName -match ' ' -and $_.PathName -notmatch '^"'
} | Select-Object Name,DisplayName,PathName,StartName
```

Check service permissions and binary/file ACLs
```
:: Service DACLs (requires AccessChk)
accesschk.exe -accepteula -ucqv "ServiceName"

:: Find services that "Authenticated Users" can change/start/stop
accesschk.exe -accepteula -uwcqv "Authenticated Users" *

:: Check write perms on the service binary and its folder
icacls "C:\Path\To\ServiceBinary.exe"
icacls "C:\Path\To"    & dir /q "C:\Path"

:: Also check intermediate folders in an unquoted path chain (e.g., C:\Program Files\Vendor\App\bin)
icacls "C:\Program Files"
icacls "C:\Program Files\Vendor"
icacls "C:\Program Files\Vendor\App"
icacls "C:\Program Files\Vendor\App\bin"
```

Map service to process and vice versa
```
:: From service to PID
sc queryex "ServiceName"

:: From PID to services it hosts (especially svchost)
tasklist /svc /fi "pid eq 1234"
```

Operational controls (if permitted)
```
:: Try stopping/starting a service (may require rights)
sc stop "ServiceName"
sc start "ServiceName"
```

## Practical tips
- Prefer built-ins first; supplement with AccessChk for precise DACL insights.
- Prioritize:
  - Auto-start services running as LocalSystem/LocalService/NetworkService.
  - Non-Microsoft binaries and paths outside C:\Windows\.
  - Unquoted service paths with spaces; check write perms along the path.
- Correlate listeners (netstat/Get-NetTCPConnection) to services; externally exposed services are high value.
- WMIC is deprecated on newer Windows but commonly available in labs; use Get-CimInstance as a modern alternative.
- Service permission escalation needs both:
  - The ability to change config or replace the binary, and
  - A way to start/restart the service (start right or a reboot/trigger).
- Use findstr filters to reduce noise; export to files if the console wraps.
- Be careful starting/stopping services on production-like systems; log and justify each action.

## Minimal cheat sheet (one-screen flow)
```
whoami /priv

:: Processes
tasklist /v
tasklist /svc
wmic process get Name,ProcessId,ExecutablePath,CommandLine
wmic process get CommandLine,ProcessId,Name | findstr /ri "pass|pwd|key|token|secret"

:: Network → PID → process
netstat -ano | findstr LISTEN
tasklist /fi "PID eq <PID>" /v

:: Services
sc queryex type= service state= all
wmic service get Name,DisplayName,State,StartMode,StartName,ProcessId,PathName
sc qc "ServiceName"

:: Unquoted paths
wmic service where "StartMode='Auto' AND PathName LIKE '% %' AND NOT PathName LIKE '\"%'" get Name,PathName,StartName

:: Weak perms (AccessChk)
accesschk.exe -accepteula -uwcqv "Authenticated Users" *
accesschk.exe -accepteula -ucqv "ServiceName"

:: File/dir ACLs
icacls "C:\Path\To\ServiceBinary.exe"
icacls "C:\Path\To"
```

## Summary
- Enumerate processes and services to surface escalation opportunities quickly.
- Extract key fields: account (StartName), start mode, binary path (quoted?), PID, command line, and hosting relationships.
- Flag unquoted service paths, weak service DACLs, and writable binaries/folders—especially for services running as SYSTEM.
- Use tasklist/sc/wmic (or PowerShell CIM) to build a clear map from ports → PIDs → processes → services and permissions.
- AccessChk accelerates permission analysis; icacls validates filesystem write paths needed for service-based privilege escalation.